# Настройка I18n

### Использование различных бэкендов

По некоторым причинам простой бэкенд, поставляющийся с Active Support, осуществляет только "простейшие вещи, в которых возможна работа" _Ruby on Rails_ (или, цитируя Википедию, Интернационализация это процесс разработки программного обеспечения таким образом, что оно может быть адаптировано к различным языкам и регионам без существенных инженерных изменений. Локализация это процесс адаптации программы для отдельного региона или языка с помощью добавления специфичных для локали компонентов и перевод текстов), что означает то, что гарантируется работа для английского и, как побочный эффект, для схожих с английским языков. А также, простой бэкенд способен только читать переводы, а не динамически хранить их в каком-либо формате.

Впрочем, это не означает, что вы связаны этими ограничениями. Гем Ruby I18n позволяет с легкостью заменить простой бэкенд на что-то иное, более предпочтительное для ваших нужд. К примеру можно заменить его на бэкенд Globalize's Static:

```ruby
I18n.backend = Globalize::Backend::Static.new
```

Также можно использовать бэкенд Chain для связывания различных бэкендов вместе. Это полезно при использовании стандартных переводов с помощью простого бэкенда, но хранении переводов приложения в базе данных или других бэкендах. Например, можно использовать бэкенд Active Record и вернуться к простому бэкенду (по умолчанию):

```ruby
I18n.backend = I18n::Backend::Chain.new(I18n::Backend::ActiveRecord.new, I18n.backend)
```

### Использование различных обработчиков исключений

API I18n определяет следующие исключения, вызываемые бэкендами, когда происходят соответствующие неожидаемые условия:

```ruby
MissingTranslationData       # не обнаружен перевод для запрашиваемого ключа
InvalidLocale                # локаль, установленная I18n.locale, невалидна (например, nil)
InvalidPluralizationData     # была передана опция count, но данные для перевода не могут быть возведены во множественное число
MissingInterpolationArgument # перевод ожидает интерполяционный аргумент, который не был передан
ReservedInterpolationKey     # перевод содержит зарезервированное имя интерполяционной переменной (т.е. scope, default)
UnknownFileType              # бэкенд не знает, как обработать тип файла, добавленного в I18n.load_path
```

API I18n поймает все эти исключения, когда они были вызваны в бэкенде, и передаст их в метод default_exception_handler. Этот метод перевызовет все исключения, кроме исключений `MissingTranslationData`. Когда было вызвано исключение `MissingTranslationData`, он возвратит строку сообщения об ошибке исключения, содержащую отсутствующие ключ/пространство имен.

Причиной для этого является то, что при разработке вам обычно хочется, чтобы вьюхи рендерились несмотря на отсутствующие переводы.

Впрочем, в иных ситуациях, возможно, захочется изменить это поведение. Например, обработка исключений по умолчанию не позволяет просто ловить отсутствующие переводы во время автоматических тестов. Для этой цели может быть определен иной обработчик исключений. Определенный обработчик исключений должен быть методом в модуле I18n или классом с методом `#call`:

```ruby
module I18n
  class JustRaiseExceptionHandler < ExceptionHandler
    def call(exception, locale, key, options)
      if exception.is_a?(MissingTranslation)
        raise exception.to_exception
      else
        super
      end
    end
  end
end

I18n.exception_handler = I18n::JustRaiseExceptionHandler.new
```

Это перевызовет только исключение `MissingTranslationData`, передав все другие значения в обработчик исключений по умолчанию.

Однако, если вы используете `I18n::Backend::Pluralization`, этот обработчик также вызывает исключение `I18n::MissingTranslationData: translation missing: en.i18n.plural.rule`, которое обычно должно быть проигнорировано для отката к правилу плюрализации по умолчанию в английской локали. Чтобы это измежать, можно добавить дополнительную проверку ключа перевода:

```ruby
if exception.is_a?(MissingTranslation) && key.to_s != 'i18n.plural.rule'
  raise exception.to_exception
else
  super
end
```

Другим примером, когда поведение по умолчанию является менее желательным, является Rails TranslationHelper, который предоставляет метод `#t` (то же самое, что `#translate`). Когда в этом контексте происходит исключение `MissingTranslationData` хелпер оборачивает сообщение в span с классом CSS `translation_missing`.

Чтобы это осуществить, хелпер заставляет `I18n#translate` вызвать исключения, независимо от того, какой обработчик исключений установлен, определяя опцию `:raise`:

```ruby
I18n.t :foo, raise: true # всегда перевызывает исключения из бэкенда
```
