# Условия

Метод `where` позволяет определить условия для ограничения возвращаемых записей, которые представляют `WHERE`-часть выражения SQL. Условия могут быть заданы как строка, массив или хэш.

### Чисто строковые условия

Если вы хотите добавить условия в свой поиск, можете просто определить их там, подобно `Client.where("orders_count = '2'")`. Это найдет всех клиентов, где значение поля `orders_count` равно 2.

WARNING: Создание условий в чистой строке подвергает вас риску SQL инъекций. Например, `Client.where("first_name LIKE '%#{params[:first_name]}%'")` не безопасно. Смотрите следующий раздел для более предпочтительного способа обработки условий с использованием массива.

### Условия с использованием массива

Что если количество может изменяться, скажем, как аргумент извне, возможно даже от пользователя? Поиск тогда принимает такую форму:

```ruby
Client.where("orders_count = ?", params[:orders])
```

Active Record проходит через первый элемент в переданных условиях, подставляя остальные элементы вместо знаков вопроса `(?)` в первом элементе.

Если хотите определить несколько условий:

```ruby
Client.where("orders_count = ? AND locked = ?", params[:orders], false)
```

В этом примере первый знак вопроса будет заменен на значение в `params[:orders]` и второй будет заменен SQL аналогом `false`, который зависит от адаптера.

Этот код значительно предпочтительнее:

```ruby
Client.where("orders_count = ?", params[:orders])
```

чем такой код:

```ruby
Client.where("orders_count = #{params[:orders]}")
```

по причине безопасности аргумента. Помещение переменной прямо в строку условий передает переменную в базу данных _как есть_. Это означает, что неэкранированная переменная, переданная пользователем, может иметь злой умысел. Если так сделать, вы подвергаете базу данных риску, так как если пользователь обнаружит, что он может использовать вашу базу данных, то он сможет сделать с ней что угодно. Никогда не помещайте аргументы прямо в строку условий!

TIP: Подробнее об опасности SQL инъекций можно узнать из [Руководства Ruby On Rails по безопасности](/ruby-on-rails-security-guide).

#### Символы-заполнители в условиях

Подобно тому, как `(?)` заменяют параметры, можно использовать хэш ключей/параметров в условиях с использованием массива:

```ruby
Client.where("created_at >= :start_date AND created_at <= :end_date",
  {:start_date => params[:start_date], :end_date => params[:end_date]})
```

Читаемость улучшится, в случае если вы используете большое количество переменных в условиях.

### Условия с использованием хэша

Active Record также позволяет передавать условия в хэше, что улучшает читаемость синтаксиса условий. В этом случае передается хэш с ключами, равными полям, к которым применяются условия, и с значениями, указывающим каким образом вы хотите применить к ним условия:

NOTE: Хэшем можно передать условия проверки только равенства, интервала и подмножества.

#### Условия равенства

```ruby
Client.where(:locked => true)
```

Имя поля также может быть строкой, а не символом:

```ruby
Client.where('locked' => true)
```

В случае отношений belongs_to, может быть использован ключ связи для указания модели, если как значение используется объект ActiveRecord. Этот метод также работает с полиморфными отношениями.

```ruby
Post.where(:author => author)
Author.joins(:posts).where(:posts => {:author => author})
```

NOTE: Значения не могут быть символами. Например, нельзя сделать `Client.where(:status => :active)`.

#### Интервальные условия

```ruby
Client.where(:created_at => (Time.now.midnight - 1.day)..Time.now.midnight)
```

Это найдет всех клиентов, созданных вчера, с использованием SQL выражения `BETWEEN`:

```sql
SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
```

Это была демонстрация более короткого синтаксиса для примеров в [Условия с использованием массива](#array-conditions)

#### Условия подмножества

Если хотите найти записи, используя выражение `IN`, можете передать массив в хэш условия:

```ruby
Client.where(:orders_count => [1,3,5])
```

Этот код создаст подобный SQL:

```sql
SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))
```
