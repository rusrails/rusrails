# Получение объектов из базы данных

Для получения объектов из базы данных Active Record предоставляет несколько методов поиска. В каждый метод поиска можно передавать аргументы для выполнения определенных запросов в базу данных без необходимости писать на чистом SQL.

Методы следующие:

* `bind`
* `create_with`
* `eager_load`
* `extending`
* `from`
* `group`
* `having`
* `includes`
* `joins`
* `limit`
* `lock`
* `none`
* `offset`
* `order`
* `preload`
* `readonly`
* `references`
* `reorder`
* `reverse_order`
* `select`
* `uniq`
* `where`

Все эти методы возвращают экземпляр `ActiveRecord::Relation`.

Вкратце основные операции `Model.find(options)` таковы:

* Преобразовать предоставленные опции в эквивалентный запрос SQL.
* Выполнить запрос SQL и получить соответствующие результаты из базы данных.
* Создать экземпляр эквивалентного объекта Ruby подходящей модели для каждой строки результата запроса.
* Запустить колбэки `after_find`, если таковые имеются.

### Получение одиночного объекта

Active Record представляет пять различных способов получения одиночного объекта.

#### Использование первичного ключа

Используя `Model.find(primary_key, options = nil)`, можно получить объект, соответствующий определенному первичному ключу (_primary key_) и предоставленным опциям. Например:

```ruby
# Ищет клиента с первичным ключом (id) 10.
client = Client.find(10)
# => #<Client id: 10, first_name: "Ryan">
```

SQL эквивалент этого такой:

```sql
SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
```

`Model.find(primary_key)` вызывает исключение `ActiveRecord::RecordNotFound`, если соответствующей записи не было найдено.

#### `take`

`Model.take` получает запись без какого-либо явного упорядочивания. Например:

```ruby
client = Client.take
# => #<Client id: 1, first_name: "Lifo">
```

SQL эквивалент этого такой:

```sql
SELECT * FROM clients LIMIT 1
```

`Model.take` возвращает `nil`, если ни одной записи не найдено, и исключение не будет вызвано.

TIP: Получаемая запись может отличаться в зависимости от движка базы данных.

#### `first`

`Model.first` находит первую запись, упорядоченную по первичному ключу. Например:

```ruby
client = Client.first
# => #<Client id: 1, first_name: "Lifo">
```

SQL эквивалент этого такой:

```sql
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
```

`Model.first` возвращает `nil`, если не найдено соответствующей записи, и исключение не вызывается.

#### `last`

`Model.last` находит последнюю запись, упорядоченную по первичному ключу. Например:

```ruby
client = Client.last
# => #<Client id: 221, first_name: "Russel">
```

SQL эквивалент этого такой:

```sql
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
```

`Model.last` возвращает `nil`, если не найдено соответствующей записи, и исключение не вызывается.

#### `find_by`

`Model.find_by` ищет первую запись, соответствующую некоторым условиям. Например:

```ruby
Client.find_by first_name: 'Lifo'
# => #<Client id: 1, first_name: "Lifo">

Client.find_by first_name: 'Jon'
# => nil
```

Это эквивалент записи:

```ruby
Client.where(first_name: 'Lifo').take
```

#### `take!`

`Model.take!` получает запись без какого-либо явного упорядочивания. Например:

```ruby
client = Client.take!
# => #<Client id: 1, first_name: "Lifo">
```

SQL эквивалент этого такой:

```sql
SELECT * FROM clients LIMIT 1
```

`Model.take!` вызывает `ActiveRecord::RecordNotFound`, если соответсвующей записи не было найдено.

#### `first!`

`Model.first!` находит первую запись, упорядоченную по первичному ключу. Например:

```ruby
client = Client.first!
# => #<Client id: 1, first_name: "Lifo">
```

SQL эквивалент этого такой:

```sql
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
```

`Model.first` вызывает `ActiveRecord::RecordNotFound`, если не найдено соответствующей записи.

#### `last!`

`Model.last!` находит последнюю запись, упорядоченную по первичному ключу. Например:

```ruby
client = Client.last!
# => #<Client id: 221, first_name: "Russel">
```

SQL эквивалент этого такой:

```sql
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
```

`Model.last` вызывает `ActiveRecord::RecordNotFound`, если не найдено соответствующей записи.

#### `find_by!`

`Model.find_by!` ищет первую запись, соответствующую некоторым условиям. Он вызывает `ActiveRecord::RecordNotFound`, если не найдено соответствующей записи. Например:

```ruby
Client.find_by! first_name: 'Lifo'
# => #<Client id: 1, first_name: "Lifo">

Client.find_by! first_name: 'Jon'
# => ActiveRecord::RecordNotFound
```

Это эквивалент записи:

```ruby
Client.where(first_name: 'Lifo').take!
```

### Получение нескольких объектов

#### Использование нескольких первичных ключей

`Model.find(array_of_primary_key)` принимает массив _первичных ключей_, возвращая массив, содержащий все соответствующие записи для предоставленных _первичных ключей_. Например:

```ruby
# Найти клиентов с первичными ключами 1 и 10.
client = Client.find([1, 10]) # Или даже Client.find(1, 10)
# => [#<Client id: 1, first_name: "Lifo">, #<Client id: 10, first_name: "Ryan">]
```

SQL эквивалент этого такой:

```sql
SELECT * FROM clients WHERE (clients.id IN (1,10))
```

WARNING: `Model.find(array_of_primary_key)` вызывает исключение `ActiveRecord::RecordNotFound`, если не найдено соответствующих записей для **всех** предоставленных первичных ключей.

#### take

`Model.take(limit)` извлекает первые несколько записей, определенных `limit` без какого-либо явного упорядочивания:

```ruby
Client.take(2)
# => [#<Client id: 1, first_name: "Lifo">,
      #<Client id: 2, first_name: "Raf">]
```

Эквивалент SQL этого следующий:

```sql
SELECT * FROM clients LIMIT 2
```

#### first

`Model.first(limit)` находит первые несколько записей, определенных `limit`, упорядоченные по первичному ключу:

```ruby
Client.first(2)
# => [#<Client id: 1, first_name: "Lifo">,
      #<Client id: 2, first_name: "Raf">]
```

Эквивалент SQL этого следующий:

```sql
SELECT * FROM clients LIMIT 2
```

#### last

`Model.last(limit)` находит несколько записей, определенных `limit`, упорядоченные по первичному ключу в порядке убывания:

```ruby
Client.last(2)
# => [#<Client id: 10, first_name: "Ryan">,
      #<Client id: 9, first_name: "John">]
```

Эквивалент SQL этого следующий:

```sql
SELECT * FROM clients ORDER By id DESC LIMIT 2
```

### Получение нескольких объектов пакетами

Часто необходимо перебрать огромный набор записей, когда рассылаем письма всем пользователям или импортируем некоторые данные.

Это может показаться простым:

```ruby
# Очень неэффективно, когда в таблице users тысячи строк.
User.all.each do |user|
  NewsLetter.weekly_deliver(user)
end
```

Но этот подход становится очень непрактичным с увеличением размера таблицы, поскольку `User.all.each` говорит Active Record извлечь _таблицу полностью_ за один проход, создать объект модели для каждой строки и держать этот массив в памяти. В реальности, если имеется огромное количество записей, полная коллекция может превысить количество доступной памяти.

Rails представляет два метода, посвященных разделению записей на дружелюбные к памяти пакеты для обработки. Первый метод, `find_each`, получает пакет записей и затем вкладывает _каждую_ запись в блок отдельно как модель. Второй метод, `find_in_batches`, получает пакет записей и затем вкладывает _весь пакет_ в блок как массив моделей.

TIP: Методы `find_each` и `find_in_batches` предназначены для пакетной обработки большого числа записей, которые не поместятся в памяти за раз. Если нужно просто перебрать тысячу записей, более предпочтителен вариант обычных методов поиска.

#### `find_each`

Метод `find_each` получает пакет записей и затем вкладывает _каждую_ запись в блок отдельно как модель. В следующем примере `find_each` получит 1000 записей (текущее значение по умолчанию и для `find_each`, и для `find_in_batches`), а затем вложит каждую запись отдельно в блок как модель. Процесс повторится, пока не будут обработаны все записи:

```ruby
User.find_each do |user|
  NewsLetter.weekly_deliver(user)
end
```

##### Опции для `find_each`

Метод `find_each` принимает большинство опций, допустимых для обычного метода `find`, за исключением `:order` и `:limit`, зарезервированных для внутреннего использования в `find_each`.

Также доступны две дополнительные опции, `:batch_size` и `:start`.

**`:batch_size`**

Опция `:batch_size` позволяет опеределить число записей, подлежащих получению в одном пакете, до передачи отдельной записи в блок. Например, для получения 5000 записей в пакете:

```ruby
User.find_each(batch_size: 5000) do |user|
  NewsLetter.weekly_deliver(user)
end
```

**`:start`**

По умолчанию записи извлекаются в порядке увеличения первичного ключа, который должен быть числом. Опция `:start` позволяет вам настроить первый ID последовательности, когда наименьший ID не тот, что вам нужен. Это полезно, например, если хотите возобновить прерванный процесс пакетирования, предоставив последний обработанный ID как контрольную точку.

Например, чтобы выслать письма только пользователям с первичным ключом, начинающимся от 2000, и получить их в пакетах по 5000:

```ruby
User.find_each(start: 2000, batch_size: 5000) do |user|
  NewsLetter.weekly_deliver(user)
end
```

Другим примером является наличие нескольких воркеров, работающих с одной и той же очередью обработки. Можно было бы обрабатывать каждым воркером 10000 записей, установив подходящие опции `:start` в каждом воркере.

#### `find_in_batches`

Метод `find_in_batches` похож на `find_each`, посколько они оба получают пакеты записей. Различие в том, что `find_in_batches` передает в блок _пакеты_ как массив моделей, вместо отдельной модели. Следующий пример передаст в представленный блок массив из 1000 счетов за раз, а в последний блок содержащий все оставшиеся счета:

```ruby
# Передает в add_invoices массив из 1000 счетов за раз.
Invoice.find_in_batches(include: :invoice_lines) do |invoices|
  export.add_invoices(invoices)
end
```

NOTE: Опция `:include` позволяет назвать связи, которые должны быть загружены вместе с моделями.

##### Опции для `find_in_batches`

Метод `find_in_batches` принимает те же опции `:batch_size` и `:start`, как и `find_each`, а также большинство опций, допустимых для обычного метода `find`, за исключением `:order` и `:limit`, зарезервированных для внутреннего использования в `find_in_batches`.
