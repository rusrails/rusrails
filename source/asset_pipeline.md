Asset Pipeline
==============

Это руководство раскрывает файлопровод (asset pipeline).

Обратившись к этому руководству, вы узнаете:

* Что такое файлопровод, и зачем он нужен.
* Как должным образом организовывать ресурсы своего приложения.
* Преимущества файлопровода.
* Как добавить препроцессор к файлопроводу.
* Как упаковывать ресурсы в гем.

(what-is-the-asset-pipeline) Что такое файлопровод (Asset Pipeline)?
--------------------------------------------------------------------

Файлопровод представляет фреймворк для соединения и минимизации или сжатия ресурсов JavaScript и CSS. Он также добавляет возможность писать эти ресурсы на других языках, таких как CoffeeScript, Sass и ERB.

Становление файлопровода как ключевой особенности Rails означает, что все разработчики могут воспользоваться мощью того, что их ресурсы будут предварительно обработаны, сжаты и минифицированы с помощью единой библиотеки, Sprockets. Это часть стратегии "fast by default", как сказал David Heinemeier Hansson на открытии RailsConf 2011.

Файлопровод по умолчанию включен. Он может быть отключен в `config/application.rb`, если поместить следующую строку в определении класса приложения:

```ruby
config.assets.enabled = false
```

Также файлопровод можно отключить при создании нового приложения, передав опцию `--skip-sprockets`.

```bash
rails new appname --skip-sprockets
```

Следует использовать значeния по умолчанию для всех новых приложений, если у вас нет особых причин избегать файлопровода.

### Основные особенности

Первой особенностью файлопровода является соединение ресурсов. Это важно в среде production, поскольку может уменьшить количество запросов, необходимых браузеру для отображения страницы. Браузеры ограничены в количестве запросов, которые они могут выполнить параллельно, поэтому меньше запросов может означать быстрейшую загрузку вашего приложения.

Rails 2.x представил способность соединять ресурсы JavaScript и CSS, при помещении `cache: true` в конце методов `javascript_include_tag` и `stylesheet_link_tag`. Но эта техника имела ряд ограничений. К примеру, нельзя было создать кэш заранее, нельзя было явно включить ресурсы, предоставленные сторонними библиотеками.

Начиная с версии 3.1, по умолчанию Rails соединеняет все JavaScript файлы в один главный файл `.js` и все CSS файлы в один главный файл `.css`. Как будет сказано далее в этому руководстве, можно настроить эту стратегию, сгруппировав файлы любым способом. В production, Rails вставляет метку MD5 в каждое имя файла, таким образом файл кэшируется браузером. Кэш можно сделать недействительным, изменив эту метку, что происходит автоматически каждый раз, когда изменяется содержимое файла.

Второй особенностью файлопровода является минимизация или сжатие ресурсов. Для файлов CSS это выполняется путем удаления пробелов и комментариев. Для JavaScript могут быть применены более сложные процессы. Можно выбирать из набора встроенных опций или опеределить свои.

Третьей особенностью файлопровода является то, что он позволяет писать эти ресурсы на языке высшего уровня с дальнейшей прекомпиляцией до фактического ресурса. Поддерживаемые языки по умолчанию включают Sass для CSS, CoffeeScript для JavaScript и ERB для обоих.

### Что за метки и зачем они нужны?

Метки - это техника, осуществляющая зависимость имени файла от его содержимого. При изменении содержимого файла, имя файла также изменяется. Для статичного или нечасто обновляемого содержимого это предоставляет легкий способ сказать, что две версии файла идентичны, даже если они на разных серверах, или имеют различную дату размещения.

Когда имя файла уникально и основано на его содержимом, заголовками HTTP можно установить повсеместное кэширование (в CDN, у провайдера, в сетевом оборудовани или браузере), чтобы у них была собственная копия содержимого. Когда содержимое изменяется, метка тоже изменится. Это приведет к тому, что удаленные клиенты затребуют новую копию содержимого. Эта техника известна как _cache busting_.

Техникой, используемой Rails для меток, является вставка хеша содержимого в имя, обычно в конце. Например, файл CSS `global.css` может быть переименован с помощью дайджеста MD5 его содержимого:

```
global-908e25f4bf641868d8683022a5b62f54.css
```

Это стратегия, принятая файлопроводом Rails.

Прежней стратегией Rails было добавление основанной на дате строки запроса к каждому ресурсу, присоединенному с помощью встроенного хелпера. В исходнике созданый код выглядел так:

```
/stylesheets/global.css?1309495796
````

У стратегии, основанной на строке запроса, имелось несколько недостатков:

1. **Не все кэши надежно кэшировали содержимое, когда имя файла отличалось только параметрами строки запроса**<br />
    [Steve Souders рекомендует](http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/), "...избегать строки запросов для кэшируемых ресурсов". Он обнаружил, что в этом случае 5-20% запросов не будут закэшированы. В частности, строки запроса совсем не работают с некоторыми сетями доставки контента (CDN) для инвалидации кэша.

2. **Имя файла может быть разным на разных узлах в мультисерверных окружениях.**<br />
    По умолчанию, строка запроса в Rails 2.x основывается на времени изменения файлов. Когда ресурсы размещаются в кластер, нет никакой гарантии, что временная метка будет одной и той же, в результате будут использованы различные значения в зависимости от того, какой сервер будет обрабатывать запрос.

3. **Слишком много прекращенного кэша**<br />
    При размещении статичных ресурсов с каждым новым релизом кода, mtime _всех_ этих файлов изменялось, принуждая всех удаленных клиентов получать их снова, даже если содержимое этих ресурсов не менялось.

Метки исправляют эти проблемы с помощью избегания строк запроса и обеспечения, что имя файла основывается на его содержимом.

По умолчанию метки включены для production и отключены для всех других сред. Их можно включить или отключить в конфигурации с помощью опции `config.assets.digest`.

Более подробно:

* [Optimize caching](http://code.google.com/speed/page-speed/docs/caching.html)
* [Revving Filenames: don’t use querystring](http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/)

(how-to-use-the-asset-pipeline) Как использовать файлопровод (Asset Pipeline)
-----------------------------------------------------------------------------

В прежних версиях Rails, все ресурсы были расположены в субдиректориях `public`, таких как `images`, `javascripts` и `stylesheets`. Сейчас, с файлопроводом, предпочтительным местом размещения для этих ресурсов стала директория `app/assets`. Файлы в этой директории отдаются промежуточной программой Sprockets, включенной в гем sprockets.

Ресурсы все еще могут быть размещены в `public`. Любой ресурс в `public` будет отдан как статичный файл приложением или веб-сервером. Следует использовать `app/assets` для файлов, которые должны пройти некоторую предварительную обработку перед тем, как будут отданы.

По умолчанию в production Rails прекомпилирует эти файлы в `public/assets`. Прекомпилированные копии затем отдаются веб-сервером как статичные ресурсы. Файлы в `app/assets` никогда не отдаются напрямую в production.

### Ресурсы конкретного контроллера

При генерации скаффолда или контроллера, Rails также генерирует файл JavaScript (или файл CoffeeScript, если гем `coffee-rails` имеется в `Gemfile`) и файл СSS (или файл SCSS, если `sass-rails` имеется в `Gemfile`) для этого контроллера.

Например, если генерируете `ProjectsController`, Rails также добавит новый файл `app/assets/javascripts/projects.js.coffee` и еще один `app/assets/stylesheets/projects.css.scss`. По умолчанию эти файлы будут готовы к немедленному использованию вашим приложением, с помощью директивы `require_tree`. Смотрите [Файлы манифеста и директивы](#manifest-files-and-directives) о подробностях require_tree.

Опционально можно включить таблицы стилей и файлы JavaScript конкретного контроллера только для их соответствующих контроллеров, используя следующее: `<%= javascript_include_tag params[:controller] %>` или `<%= stylesheet_link_tag params[:controller] %>`. Однако, убедитесь, что не используете директиву `require_tree`, так как это приведет к тому, что ресурсы будут включены более одного раза.

WARNING: При использовании прекомпиляции ресурсов (по умолчанию в production), необходимо убедиться, что ресурсы контроллера будут прекомпилированы при варианте загрузки их на основе страницы. По умолчанию файлы .coffee и .scss не будут прекомпилированы отдельно. Это приведет к видимости правильной работы при разработке, так как эти файлы будут работать, так как ресурсы компилируются на лету. Однако, при запуске на production, вы увидите ошибки 500, так как компиляция на лету по умолчанию отключена. Смотрите [Прекомпиляция ресурсов](#in-production) о подробностях работы прекомпиляции.

NOTE: Вам необходим runtime, поддерживаемый ExecJS, чтобы использовать CoffeeScript. Если используете Mac OS X или Windows, у вас уже имеется JavaScript runtime, установленный в операционной системе. Обратитесь к документации по [ExecJS](https://github.com/sstephenson/execjs#readme), чтобы узнать обо всех поддерживаемых JavaScript runtime-ах.

Отключить создание ресурсов при генерации контроллера можно, добавив следующее в конфигурацию `config/application.rb`:

```ruby
config.generators do |g|
  g.assets false
end
```

### Организация ресурсов

Ресурсы файлопровода могут быть размещены в приложении в одном из этих трех мест: `app/assets`, `lib/assets` или `vendor/assets`.

`app/assets` предназначено для ресурсов, принадлежащих приложению, таких как изображения, файлы JavaScript или таблицы стилей, изготовленные специально для приложения.

`lib/assets` предназначено для кода ваших собственных библиотек, которые не вписываются в сферу применения приложения или эти библиотеки используются в нескольких приложениях.

`vendor/assets` предназначено для ресурсов, принадлежащих сторонним субъектам, таких как код плагинов JavaScript и фреймворки CSS.

#### Пути поиска

Когда к файлу обращаются из манифеста или хелпера, Sprockets ищет в трех дефолтных местах размещения ресурсов для этого.

Дефолтные места следующие: `app/assets/images` и поддиректории `javascripts` и `stylesheets` во всех трех метах размещения ресурсов, но эти поддиректории не особенные. Поиск будет вестись по любому пути в `assets/*`.

Для примера, на эти файлы:

```
app/assets/javascripts/home.js
lib/assets/javascripts/moovinator.js
vendor/assets/javascripts/slider.js
vendor/assets/somepackage/phonebox.js
```

можно сослаться в манифесте таким образом:

```js
//= require home
//= require moovinator
//= require slider
//= require phonebox
```

Ресурсы в поддиректориях также доступны.

```
app/assets/javascripts/sub/something.js
```

доступен как:

```js
//= require sub/something
```

Можно просмотреть путь поиска, проинспектировав `Rails.application.config.assets.paths` в консоли Rails.

Помимо стандартных путей `assets/*` в файлопровод могут быть добавлены дополнительные (полные) пути в `config/application.rb`. Например:

```ruby
config.assets.paths << Rails.root.join("lib", "videoplayer", "flash")
```

Пути обходятся в том порядке, в котором они выводятся в пути поиска. По умолчанию это означает, что имеют преимущество файлы в `app/assets`, они перекроют соотвествующие пути в `lib` и `vendor`.

Важно заметить, что если хотите сослаться на что-то еще, в прекомпиляционный массив должен быть добавлен манифест, или оно не будет доступно в среде production.

#### Использование индексных файлов

Sprockets использует файлы с именем `index` (с соответствующим расширением) для специальных целей.

Например, если имеется бибилиотека jQuery с множеством модулей, хранящаяся в `lib/assets/library_name`, файл `lib/assets/library_name/index.js` служит манифестом для всех файлов в этой библиотеке. Этот файл может включать список всех требуемых файлов в нужном порядке, или просто директиву `require_tree`.

Библиотека в целом может быть доступна из манифеста приложения следующим образом:

```js
//= require library_name
```

Это упрощает поддержку и сохраняет чистоту, позволяя коду быть сгруппированным перед включением где-нибудь еще.

### Кодирование ссылок на ресурсы

Sprockets не добавляет какие-либо новые методы для доступа к вашим ресурсам - используйте знакомые методы `javascript_include_tag` и `stylesheet_link_tag`.

```erb
<%= stylesheet_link_tag "application" %>
<%= javascript_include_tag "application" %>
```

В обычных вьюхах можно получить доступ к изображениям в директории `assets/images` следующим образом:

```erb
<%= image_tag "rails.png" %>
```

При условии, что файлопровод включен в вашем приложении (и не отключен в контексте текущей среды), этот файл будет отдан Sprockets'ом. Если файл существует в `public/assets/rails.png`, он будет отдан веб-сервером.

Кроме того, запрос файла с хешем MD5, такого как `public/assets/rails-af27b6a414e6da00003503148be9b409.png` будет обработан тем же образом. Как генерируются эти хеши раскрыто в позже в этом руководстве в разделе [В production](#in-production).

Sprockets также будет смотреть в путях, определенных в `config.assets.paths`, включающие стандартные пути приложения и любой путь, добавленный engine-ами Rails.

Изображения также могут быть организованы в субдиректории и могут быть доступны с помощью указания имени директории в теге:

```erb
<%= image_tag "icons/rails.png" %>
```

WARNING: Если вы прекомпилируете ресурсы (смотрите раздел [В production](#in-production) далее), связывание с несуществующим ресурсом вызовет исключение на вызывающей странице. Это включает связывание с пустой строкой. Поэтому будьте острожны при использовании `image_tag` и других хелперов с данными, предоставленными пользователями.

#### CSS и ERB

Файлопровод автоматически вычислят ERB. Это означает, что, если добавить расширение `erb` к ресурсу CSS (например, `application.css.erb`), тогда будут доступны хелперы, такие как `asset_path`, в правилах вашего CSS:

```css
.class { background-image: url(<%= asset_path 'image.png' %>) }
```

Это записывает путь к определенному указанному ресурсу. Этот пример имеет смысл если имеется изображение в одном из путей загрузки ресурсов, такое как `app/assets/images/image.png`, на которое тут будет ссылка. Если это изображение уже имеется в `public/assets` как файл с меткой, то будет ссылка на него.

Если хотите использовать [data URI](http://ru.wikipedia.org/wiki/Data:_URL) - метод встравивания данных изображения непосредственно в файл CSS - используйте хелпер `asset_data_uri`.

```css
#logo { background: url(<%= asset_data_uri 'logo.png' %>) }
```

Это вставит правильно отформатированный URI в код CSS.

Отметьте, что закрывающий тег не может быть стиля `-%>`.

#### CSS и Sass

При использовании файлопровода пути к ресурсам должны быть переписаны и `sass-rails` представляет хелперы `-url` и `-path` helpers (через дефис в Sass, через подчеркивание в Ruby) для следующих типов ресурсов: изображение, шрифт, видео, аудио, JavaScript и таблица стилей.

* `image-url("rails.png")` становится `url(/assets/rails.png)`
* `image-path("rails.png")` становится `"/assets/rails.png"`.

Также может быть использована более общая форма, но должны быть указаны и путь к ресурсу, и его класс:

* `asset-url("rails.png", image)` становится `url(/assets/rails.png)`
* `asset-path("rails.png", image)` становится `"/assets/rails.png"`

#### JavaScript/CoffeeScript и ERB

Если добавить расширение `erb` к ресурсу JavaScript, сделав его чем-то вроде `application.js.erb`, можно использовать хелпер `asset_path` в коде вашего JavaScript:

```erb
$('#logo').attr({
  src: "<%= asset_path('logo.png') %>"
});
```

Это записывает путь к определенному указанному ресурсу.

Подобным образом можно использовать хелпер `asset_path` в файлах CoffeeScript с расширением `erb` (т.е. `application.js.coffee.erb`):

```js
$('#logo').attr src: "<%= asset_path('logo.png') %>"
```

### (manifest-files-and-directives) Файлы манифеста и директивы

Sprockets использует файлы манифеста для определения, какие ресурсы включать и отдавать. Эти файлы манифеста содержат _директивы_ - инструкции, говорящие Sprockets, какие файлы требуются для создания отдельного файла CSS или JavaScript. С помощью этих директив Sprockets загружает указанные файлы, при необходимости их обрабатывает, соединяет в отдельный файл и затем сжимает их (если `Rails.application.config.assets.compress` равно true). При отдаче одного файла, а не нескольких, время загрузки страницы значительно уменьшается, поскольку браузер делает меньше запросов. Компрессия также уменьшает размер файла, что позволяет браузеру быстрее его скачать.

К примеру, новое приложение Rails включает дефолтный файл `app/assets/javascripts/application.js`, содержащий следующие строки:

```js
// ...
//= require jquery
//= require jquery_ujs
//= require_tree .
```

В файлах JavaScript директивы начинаются с `//=`. В этом примере файл использует директивы `require` и `require_tree`. Директива `require` используется, чтобы указать Sprockets на требуемые файлы. Здесь затребованы файлы `jquery.js` и `jquery_ujs.js`, которые доступны где-то по пути поиска для Sprockets. Не нужно явно указывать расширение. Sprockets предполагает, что вы требуете файл `.js`, когда выполняется из файла `.js`.

Директива `require_tree` говорит Sprockets рекурсивно включить _все_ файлы JavaScript в указанной директории в результирующий файл. Эти пути должны быть определены только относительно файла манифеста. Также можно использовать директиву `require_directory`, включающая все файлы JavaScript только в определенной директории, без рекурсии .

Директивы обрабатываются сверху вниз, но порядок, в котором файлы включаются с помощью `require_tree` не определен. Не следует полагаться на какой-то определенный порядок при ее использовании. Если хотите убедиться, что какой-то определенный JavaScript закончится до некоторого другого в объединенном файле, затребуйте нужный файл раньше в манифесте. Отметьте, что семейство директив `require` предотвращает от повторного включения файлов в результирующий файл.

Rails также создает дефолтный файл `app/assets/stylesheets/application.css`, содержащий эти строки:

```css
/* ...
*= require_self
*= require_tree .
*/
```

Директивы, работающие в файлах JavaScript, также работают в таблицах стилей (хотя, очевидно, включая таблицы стилей вместо JavaScript). В манифесте CSS директива `require_tree` работает так же, как и для JavaScript, включающая все таблицы стилей из текущей директории.

В этом примере использована `require_self`. Это помещает CSS, содержащийся в файле (если есть) в месте расположения вызова `require_self`. Если `require_self` вызывается более одного раза, учитывается только последний вызов.

NOTE. Если хотите использовать несколько файлов Sass, как правило следует использовать [правило Sass `@import`](http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#import) вместо директив Sprockets. При использовании директив Sprockets все файлы существуют в своей собственной области видимости, что делает переменные или примеси (mixins) доступными только в документе, их определяющем.

Можно иметь сколько угодно манифестов. Для примера, манифесты `admin.css` и `admin.js` могут содержать файлы JS и CSS, используемые для административного раздела приложения.

Применяются те же оговорки о порядке следования, что сделаны выше. В частности, можно определить отдельные файлы и порядок, в котором они будут компилироваться. Например, можно соединить три файла CSS вместе следующим образом:

```css
/* ...
*= require reset
*= require layout
*= require chrome
*/
```

### Предварительная обработка

Расширение, использованное у ресурса, определяет, какая будет применена предварительная обработка. Когда генерируется скаффолд или контроллер с помощью дефолтного набора гемов Rails, создадутся файл CoffeeScript и файл SCSS вместо обычных файлов JavaScript и CSS. В использованном ранее примере был контроллер с именем "projects", который создал файлы `app/assets/javascripts/projects.js.coffee` и `app/assets/stylesheets/projects.css.scss`.

Когда запрашиваются эти файлы, они обрабатываются процессорами, представленными гемами `coffee-script` и `sass`, а затем отдаются браузеру как JavaScript и CSS соответственно.

Может быть запрошен дополнительный уровень обработки, если добавить другое расширение, каждое расширение обрабатывается в порядке справа налево. Их следует использовать в том порядке, в котором должна быть применена обработка. Например, таблица стилей с именем `app/assets/stylesheets/projects.css.scss.erb` сначала обрабатывается как ERB, затем SCSS и, наконец, отдается как CSS. То же самое применимо к файлу JavaScript - `app/assets/javascripts/projects.js.coffee.erb` обрабатывается как ERB, затем CoffeeScript и отдается как JavaScript.

Помните, что порядок этих препроцессоров важен. Например, если вызовите свой файл JavaScript `app/assets/javascripts/projects.js.erb.coffee`, то он будет сначала обработан интерпретатором CoffeeScript, который не понимает ERB, и, следовательно, возникнут проблемы.

(in-development) В development
------------------------------

В режиме development ресурсы отдаются как отдельные файлы в порядке, в котором они определены в файле манифеста.

Этот манифест `app/assets/javascripts/application.js`:

```js
//= require core
//= require projects
//= require tickets
</plain>

сгенерирует этот HTML:

```html
<script src="/assets/core.js?body=1"></script>
<script src="/assets/projects.js?body=1"></script>
<script src="/assets/tickets.js?body=1"></script>
```

Параметр `body` требуется Sprockets.

### Отключение отладки

Можно отключить режим отладки, обновив `config/environments/development.rb`, вставив:

```ruby
config.assets.debug = false
```

Когда режим отладки отключен, Sprockets соединяет все файлы и запускает необходимые препроцессоры. С отключенным режимом отладки вышеуказанный манифест создаст:

```html
<script src="/assets/application.js"></script>
```

Ресурсы компилируются и кэшируются при первом запросе после запуска сервера. Sprockets устанавливает HTTP заголовок `must-revalidate` Cache-Control для уменьшения нагрузки на последующие запросы - на них браузер получает отклик 304 (Not Modified).

Если какой-либо из файлов в манифесте изменился между запросами, сервер возвращает новый скомпилированный файл.

Режим отладки также может быть включен в методе хелпера Rails:

```erb
<%= stylesheet_link_tag "application", debug: true %>
<%= javascript_include_tag "application", debug: true %>
```

Опция `:debug` излишняя, если режим отладки включен.

Потенциально можно включить сжатие в режиме development в качестве проверки на нормальность и отключать его по требованию, когда необходимо для отладки.

(in-production) В production
----------------------------

В среде production Rails использует схему меток, [описанную ранее](#what-is-the-asset-pipeline). По умолчанию Rails полагает, что ресурсы прекомпилированы и будут отданы как статичные ресурсы вашим веб-сервером.

В течение фазы прекомпиляции из содержимого компилированных файлов создается MD5 и вставляется в имена файлов, когда они записываются на диск. Эти имена меток используются хелперами Rails вместо имени манифеста.

Например, это:

```erb
<%= javascript_include_tag "application" %>
<%= stylesheet_link_tag "application" %>
```

создаст что-то наподобие этого:

```html
<script src="/assets/application-908e25f4bf641868d8683022a5b62f54.js"></script>
<link href="/assets/application-4dd5b109ee3439da54f5bdfd78a80473.css" media="screen" rel="stylesheet" />
```

Note: с Asset Pipeline опции :cache и :concat больше не используются, удалите эти опции из `javascript_include_tag` и `stylesheet_link_tag`.

Режим меток контролируется установкой настройки `config.assets.digest` в Rails (которая по умолчанию `true` для production, `false` для всего остального).

NOTE: В нормальных обстоятельствах опция по умолчанию не должна изменяться. Если нет дайджеста в именах файлов и установлены заголовки с вечным кэшированием, удаленные клиенты никогда не узнают, когда перезапросить файлы при изменении ихсодержимого.

### Прекомпиляция ресурсов

В Rails имеется встроенная задача rake для компиляции на диск манифестов ресурсов и других файлов в файлопроводе.

Скомпилированные ресурсы записываются в адрес, указанный в `config.assets.prefix`. По умолчанию это директория `public/assets`.

Эту задачу можно вызвать на сервере во время деплоймента, чтобы создать скомпилированные версии ресурсов непосредствено на сервере. Смотрите следующий размер, чтобы узнать о том, как скомпилировать локально.

Задача rake такая:

```bash
bundle exec rake assets:precompile
```

Для быстрой прекомпиляции ресурсов можно частично загрузить свое приложение, установив `config.assets.initialize_on_precompile` в false в `config/application.rb`, хотя в этом случае шаблоны не смогут видеть объекты или методы приложения. **Heroku требует, чтобы было false.**

WARNING: Если установить `config.assets.initialize_on_precompile` в false, до деплоя протестируйте `rake assets:precompile` локально. Это может вызвать баги, когда ваши ресурсы ссылаются на объекты или методы приложения, так как они все в режиме development они все еще находятся в области видимости независимо от значения этого флажка. Изменение этого флажка также влияет на engine. Engine также может определять ресурсы для прекомпиляции. Пока окружение полностью не загружено, engine (или другие гемы) не будут загружены, что может привести к отсутствущим ресурсам.

Capistrano (v2.8.0 и выше) включает рецепт для управления этим при деплое. Добавьте следующую строку в `Capfile`:

```erb
load 'deploy/assets'
```

Это свяжет папку, указанную в `config.assets.prefix` с `shared/assets`. Если вы уже используете эту общую папку, вам следует написать собственную задачу для деплоя.

Важно то, что эта папка является общей между деплоями, так что удаленно кэшированные страницы, ссылающиеся на старые скомпилированные ресурсы, все еще будут работать, пока не истечет срок кэширования.

NOTE. Если вы прекомпилируете ресурсы локально, на сервере можно использовать `bundle install --without assets`, чтобы избежать установки гемов для ресурсов (гемов в группе assets в Gemfile).

По умолчанию компилирующиеся файлы включают `application.js`, `application.css` и все не-JS/CSS файлы (это автоматически включает все ресурсы изображений):

```ruby
[ Proc.new { |path| !%w(.js .css).include?(File.extname(path)) }, /application.(css|js)$/ ]
```

NOTE. Условие отбора (и другие части прекомпиляционного массива; смотрите выше) применяется к итоговым скомпилированным именам файлов. Это означает, что все, что компилируется в JS/CSS, исключается, так же, как и файлы с чистым JS/CSS; например, файлы `.coffee` и `.scss` *не* включаются автоматически, так как они компилируются в JS/CSS.

Если у вас имеются для включения другие манифесты или отдельные таблицы стилей или файлы JavaScript, их можно добавить в массив `precompile`:

```erb
config.assets.precompile `= ['admin.js', 'admin.css', 'swfObject.js']
```

Или можно прекомпилировать все ресурсы, например так:

```ruby
# config/environments/production.rb
config.assets.precompile << Proc.new do |path|
  if path =~ /\.(css|js)\z/
    full_path = Rails.application.assets.resolve(path).to_path
    app_assets_path = Rails.root.join('app', 'assets').to_path
    if full_path.starts_with? app_assets_path
      puts "including asset: " + full_path
      true
    else
      puts "excluding asset: " + full_path
      false
    end
  else
    false
  end
end
```

NOTE. Всегда определяйте ожидаемое имя скомпилированного файла, оканчивающееся на js или css, даже если хотите добавить в массив прекомпиляции файлы Sass или CoffeeScript.

Задача rake также создает `manifest.yml`, который содержит список всех ваших ресурсов и их соответствующие метки. Это используется методами хелпера Rails, чтобы избежать направления запроса в Sprockets. Обычный файл манифеста выглядит так:

```
---
rails.png: rails-bd9ad5a560b5a3a7be0808c5cd76a798.png
jquery-ui.min.js: jquery-ui-7e33882a28fc84ad0e0e47e46cbf901c.min.js
jquery.min.js: jquery-8a50feed8d29566738ad005e19fe1c2d.min.js
application.js: application-3fdab497b8fb70d20cfc5495239dfc29.js
application.css: application-8af74128f904600e41a6e39241464e03.css
```

Размещение манифеста по умолчанию - корень папки, определенной в `config.assets.prefix` (по умолчанию '/assets').

NOTE: Если в production отсутствуют прекомпилированные файлы, вы получите исключение `Sprockets::Helpers::RailsHelper::AssetPaths::AssetNotPrecompiledError`, указывающее имя отсутствующего файла(-ов).

#### Вечный заголовок Expires

Прекомпилированные ресурсы существуют в файловой системе и отдаются непосредственно веб-сервером. По умолчанию у них нет заголовков вечного кэширования, таким образом, чтобы получить преимущество от меток, необходимо обновить конфигурацию вашего сервера.

Для Apache:

```apache
# Директивы Expires* требуют, чтобы модуль Apache `mod_expires` был включен.
<Location /assets/>
  # Не рекомендуется использование ETag, когда присутствует Last-Modified
  Header unset ETag
  FileETag None
  # RFC предписывает кэшировать только на 1 год
  ExpiresActive On
  ExpiresDefault "access plus 1 year"
</Location>
```

Для nginx:

```nginx
location ~ ^/assets/ {
  expires 1y;
  add_header Cache-Control public;

  add_header ETag "";
  break;
}
```

#### Сжатие GZip

При прекомпиляции файлов Sprockets также создает [gzipped](http://en.wikipedia.org/wiki/Gzip) (.gz) версию ваших ресурсов. Web серверы обычно настроены использовать умеренный уровень сжатия как компромисс, но, поскольку прекомпиляция случается единожды, Sprockets использует максимальный уровень компрессии, что уменьшает размер передачи данных до минимума. С другой стороны, веб-серверы могут быть настроены отдавать сжатый контент непосредственно с диска, не сжимая сами несжатые файлы.

Nginx может это делать автоматически, если включить `gzip_static`:

```nginx
location ~ ^/(assets)/  {
  root /path/to/public;
  gzip_static on; # to serve pre-gzipped version
  expires max;
  add_header Cache-Control public;
}
```

Эта директива доступна, если модуль, предоставляющий эту возможность, был скомпилирован вместе с веб-сервером. Пакеты Ubuntu, даже `nginx-light`, имеют этот модель скомпилированым. Иначе необходимо выполнить ручную компиляцию:

```bash
./configure --with-http_gzip_static_module
```

Если компилируете nginx вместе с Phusion Passenger, необходимо передать эту опцию, когда будет предложено.

Apache также способен отдавать [gzipped](http://en.wikipedia.org/wiki/Gzip) версию ваших ресурсов; однако, это требует немного работы:

```apache
<LocationMatch "^/assets/.*$">
  Header unset ETag
  FileETag None

  # RFC says only cache for 1 year
  ExpiresActive On
  ExpiresDefault "access plus 1 year"

  RewriteEngine	On
  RewriteCond %{HTTP:Accept-Encoding} gzip
  RewriteCond %{HTTP_USER_AGENT} !Konqueror
  RewriteCond %{REQUEST_FILENAME}.gz -f
  RewriteRule ^(.+).(css|js)$ $1.$2.gz [QSA,L]
</LocationMatch>

<FilesMatch \.css\.gz>
  ForceType text/css
</FilesMatch>

<FilesMatch \.js\.gz>
  ForceType application/javascript
</FilesMatch>
AddEncoding gzip .gz
```

NOTE: Следует убедиться, что загружены `mod_headers`, `mod_mime` и `mod_rewrite`; В противном случае вышеописанная конфигурация не сработает.

### Локальная прекомпиляция

Имеется несколько причин того, что может возникнуть желание компилировать ресурсы локально. Вот некоторые из них:

* У вас нет права записи в файловую систему production.
* Вы размещаетесь более чем на одном сервере и хотите избежать дублирования работы.
* Вы часто производите деплои, не включающие изменения ресурсов.

Локальная компиляция позволяет зафиксировать скомпилироанные файлы в управлении версиями и деплоить, как обычно.

Однако есть две оговорки:

* Вы не должны запускать задачу Capistrano, которая компилирует ресурсы.
* Вы должны изменить две следующие конфигурационные настройки приложения.

В `config/environments/development.rb` поместите следующую строчку:

```ruby
config.assets.prefix = "/dev-assets"
```

И также необходимо в application.rb:

```ruby
config.assets.initialize_on_precompile = false
```

Изменение `prefix` позволяет Rails использовать другой URL для обслуживания ресурсов в режиме development и передавать все запросы в Sprockets. Префикс остался установленным `/assets` в режиме production. Без этого изменения приложение будет обслуживаться прекомпилированными ресурсами из `public/assets` в development, и вы не увидите какие-либо локальные изменения, пока снова не скомпилируете ресурсы.

Изменение `initialize_on_precompile` сообщает таску прекомпиляции запускаться без вызова Rails. Это так, потому что таск прекомпиляции запускается по умолчанию в режиме production и попытается соединиться с базой данных, определенной для production. Отметьте, пожалуйста, что в файлах файлопровода не должно быть кода, основанного на ресурсах Rails (таких как база данных) при локальной компиляции с этой опцией.

Также необходимо убедиться, что в вашей development системе доступны используемые компрессоры или минифайеры.

На практике это позволит прекомпилировать локально, держать эти файлы в рабочей ветке и при необходимости фиксировать в системе контроля версий. Режим development будет работать так, как от от него ожидается.

### Компиляция в реальном времени

В некоторых обстоятельствах вам, возможно, захочется использовать компиляцию в реальном времени. В этом режиме все запросы для ресурсов в файлопроводе обрабатываются непосредственно Sprockets.

Чтобы включить эту опцию, установите:

```ruby
config.assets.compile = true
```

При первом запросе ресурсы компилируются и кэшируются так, как описывалось в разделе про [development](#in-development), и имена манифеста, использованного в хелперах, изменяется путем ключения хеша MD5.

Sprockets также устанавливает HTTP заголовок `Cache-Control` как `max-age=31536000`. Это сигнализирует всем кэшам между вашим сервером и браузером клиента, что это содержимое (отданный файл) может быть закэшировано на 1 год. В результате уменьшается количество запросов для этого ресурса на ваш сервер; есть хороший шанс, что ресурс будет в локальном кэше браузера или в каком-либо промежуточном кэше.

Этот режим использует больше памяти, имеет худшее быстродействие, чем по умолчанию, и не рекомендуется.

Если приложение размещается в системе без существующего JavaScript runtimes, возможно захочетсв добавить это в Gemfile:

```ruby
group :production do
  gem 'therubyracer'
end
```

### CDN

Если ваши ресурсы отдаются с CDN, убедитесь, что они не остаются в кэше вечно. Это может вызвать проблемы. Если использовать `config.action_controller.perform_caching = true`, Rack::Cache будет использовать `Rails.cache` для хранения ресурсов. Это может привести к тому, что ваш кэш быстро заполнится.

Каждый кэш различен, поэтому вычисляйте, как ваш CDN управляет кэшированием, и убеждайтесь, что он хорошо работает с файлопроводом. Можно обнаружить причуды, относящиеся к определенным настройкам, можно не найти. Использование nginx с настройками по умолчанию, к примеру, не должно давать проблем при исользовании в качестве кэша HTTP.

Настройка файлопровода
----------------------

### Сжатие CSS

Имеется всего один вариант для сжатия CSS, YUI. [YUI CSS compressor](http://developer.yahoo.com/yui/compressor/css.html) представляет минификацию.

Следующая строка включает сжатие YUI и требует гем `yui-compressor`.

```ruby
config.assets.css_compressor = :yui
```

`config.assets.compress` должна быть установлена в `true`, чтобы включить сжатие CSS.

### Сжатие JavaScript

Возможные варианты для сжатия JavaScript это `:closure`, `:uglifier` and `:yui`. Они требуют использование гемов `closure-compiler`, `uglifier` или `yui-compressor` соответственно.

Gemfile по умолчанию включает [uglifier](https://github.com/lautis/uglifier). Этот гем оборачивает [UglifierJS](https://github.com/mishoo/UglifyJS) (написанный для) в Ruby. Он сжимает ваш код, убирая пробелы. Он также включает иные операции, наподобие замены ваших выражений `if` и `else` на тренарные операторы там, где возможно.

Следующая строка вызывает `uglifier` для сжатия JavaScript.

```ruby
config.assets.js_compressor = :uglifier
```

Отметьте, что `config.assets.compress` должна быть установлена `true`. чтобы включить сжатие JavaScript

NOTE: Необходим runtime, поддерживаемый [ExecJS](https://github.com/sstephenson/execjs#readme), чтобы использовать `uglifier`. Если используете Mac OS X или Windows, у вас уже имеется JavaScript runtime, установленный в операционной системе. Обратитесь к документации по [ExecJS](https://github.com/sstephenson/execjs#readme), чтобы узнать обо всех поддерживаемых JavaScript runtime-ах.

### Использование собственного компрессора

Настройки конфигурации компрессора для CSS и JavaScript также могут принимать любой объект. Этот объект должен иметь метод `compress`, принимающий строку как единственный аргумент, и он должен возвращать строку.

```ruby
class Transformer
  def compress(string)
    do_something_returning_a_string(string)
  end
end
```

Чтобы его включить, передайте `new` объект в настройку конфигурации в `application.rb`:

```ruby
config.assets.css_compressor = Transformer.new
```

### Изменение пути _assets_

Публичный путь, используемый Sprockets по умолчанию, это `/assets`.

Он может быть заменен на что-то другое:

```ruby
config.assets.prefix = "/some_other_path"
```

Это удобная опция, если вы обновляете старый проект, не использующий файлопровод и уже использующий этот путь, или вы хотите использовать этот путь для нового ресурса.

### Заголовки X-Sendfile

Заголовок X-Sendfile это указание веб-серверу игнорировать отклик от приложения, и вместо этого отдать определенный файл с диска. Эта опция отключена по умолчанию, но может быть включена, если ее поддерживает сервер. Когда опция включена, обязанность по отдаче файла передается веб-серверу, который быстрее.

Apache и nginx поддерживают эту опцию, которая включается в `config/environments/production.rb`.

```ruby
# config.action_dispatch.x_sendfile_header = "X-Sendfile" # for apache
# config.action_dispatch.x_sendfile_header = 'X-Accel-Redirect' # for nginx
```

WARNING: Если вы обновляете свое существующее приложение и намереваетесь использовать эту опцию, убедитесь, что скопировали эту опцию только в `production.rb` и в любую другую среду, которую вы определили, как имеющую поведение production (не в `application.rb`).

Хранилище кэша ресурсов
-----------------------

Sprockets использует хранилище кэша Rails по умолчанию для кэширования ресурсов в development и production. Это может быть изменено настройкой `config.assets.cache_store`.

```ruby
config.assets.cache_store = :memory_store
```

Опции, принимаемые хранилищем кэша ресурсов, те же самые, что и для хранилища кэша приложения.

```ruby
config.assets.cache_store = :memory_store, { :size => 32.megabytes }
```

Добавление ресурсов в ваши гемы
-------------------------------

Ресурсы также могут идти от внешних источников в виде гемов.

Хорошим примером этого является гем `jquery-rails`, поставляющийся вместе с Rails как гем стандартной JavaScript библиотеки. Этот гем содержит класс engine, унаследованный от `Rails::Engine`. Сделав так, Rails становится проинформированным, что директории для этого гема могут содержать ресурсы, и директории `app/assets`, `lib/assets` и `vendor/assets` этого engine добавляются в путь поиска Sprockets.

Создание препроцессора в вашей библиотеке или геме
--------------------------------------------------

Так как Sprockets использует [Tilt](https://github.com/rtomayko/tilt) как основной интерфейс для различных движков шаблонов, ваш гем должен просто реализовать протокол шаблонов Tilt. Обычно следует унаследовать подкласс от `Tilt::Template` и переопределить метод `evaluate`, возвращающий конечный результат. Исходник шаблона хранится в `@code`. Чтобы узнать больше, взгляните на исходники[`Tilt::Template`](https://github.com/rtomayko/tilt/blob/master/lib/tilt/template.rb).

```ruby
module BangBang
  class Template < ::Tilt::Template
    # Добавляет "!" к оригинальному шаблону.
    def evaluate(scope, locals, &block)
      "#{@code}!"
    end
  end
end
```

Теперь, когда у вас есть класс `Template`, пришло время связать его с расширением для файлов шаблона:

```ruby
Sprockets.register_engine '.bang', BangBang::Template
```

Обновление со старых версий Rails
---------------------------------

Имеется несколько проблем при обновлении. Первая это перемещение файлов из `public/` в новые места размещения. Смотрите [Организация ресурсов](#how-to-use-the-asset-pipeline) ранее в руководстве для правильного размешения файлов разных типов.

Следующей является избегание дублирования файлов JavaScript. Так как jQuery является библиотекой JavaScript по умолчанию, начиная с Rails 3.1 и далее, не нужно купировать `jquery.js` в `app/assets`, он будет включен автоматически.

Третья это обновление файлов различных сред с правильными значениями по умолчанию. Следующие изменения отражают значения по умолчанию в версии 3.1.0.

В `application.rb`:

```ruby
# Включить файлопровод
config.assets.enabled = true

# Версия ваших ресурсов, измените ее, если хотие, чтобы срок существующих ресурсов истек
config.assets.version = '1.0'

# Измените путь, откуда отдаются ресурсы
# config.assets.prefix = "/assets"
```

В `development.rb`:

```ruby
# Не сжимать ресурсы
config.assets.compress = false

# Разворачивать строки, загружающие ресурсы the lines which load the assets
config.assets.debug = true
```

И в `production.rb`:

```ruby
# Сжимать JavaScripts и CSS
config.assets.compress = true

# Выбрать используемый компрессор
# config.assets.js_compressor  = :uglifier
# config.assets.css_compressor = :yui

# Не обращаться к файлопроводу, если отсутствует прекомпилированный ресурс
config.assets.compile = false

# Создавать дайджесты для URL ресурсов.
config.assets.digest = true

# Прекомпилировать дополнительные ресурсы (application.js, application.css и все не-JS/CSS уже добавлены)
# config.assets.precompile `= %w( search.js )
```

Не нужно изменять `test.rb`. По умолчанию в среде test: `config.assets.compile` равно true и `config.assets.compress`, `config.assets.debug` и `config.assets.digest` равны false.

Следующее также должно быть добавлено в `Gemfile`:

```ruby
# Гемы, используемые только для ресурсов и не требуемые
# в среде production по умолчанию.
group :assets do
  gem 'sass-rails',   "~> 3.2.3"
  gem 'coffee-rails', "~> 3.2.1"
  gem 'uglifier'
end
```

Если используете группу `assets` с Bundler, убедитесь, что в вашем `config/application.rb` имеется следующее выражение Bundler require.

```ruby
if defined?(Bundler)
  # If you precompile assets before deploying to production, use this line
  Bundler.require *Rails.groups(:assets => %w(development test))
  # If you want your assets lazily compiled in production, use this line
  # Bundler.require(:default, :assets, Rails.env)
end
```

Вместо старого из Rails версии 3.0

```ruby
# If you have a Gemfile, require the gems listed there, including any gems
# you've limited to :test, :development, or :production.
Bundler.require(:default, Rails.env) if defined?(Bundler)
```
