# Управление пользователями

NOTE: _Почти каждое веб приложение работает с авторизацией и аутентификацией. Вместо использования собственных, возможно использование внешних плагинов. Но их нужно также обновлять. Несколько дополнительных мер предосторожности сделают ваше приложение более безопасным._

Для Rails имеется ряд аутентификационных плагинов. Хорошие, такие как [devise](https://github.com/plataformatec/devise) и [authlogic](https://github.com/binarylogic/authlogic), сохраняют пароли только зашифрованными, а не чистым текстом. В Rails 3.1 можно использовать встроенный метод `has_secure_password`, имеющий похожие возможности.

Каждый новый пользователь получает активационный код для активации своего аккаунта по e-mail со ссылкой в нем. После активации аккаунта столбец activation_code в базе данных будет установлен как NULL. Если кто-то запросит следующий URL, он войдет как первый активированный пользователь, найденный в базе данных (а это, скорее всего, администратор):

```
http://localhost:3006/user/activate
http://localhost:3006/user/activate?id=
```

Это возможно, поскольку на некоторых серверах это приведет к тому, что параметр id, как params[:id], будет равен nil. Однако, вот поиск из экшна activation:

```ruby
User.find_by_activation_code(params[:id])
```

Если параметр был nil, результирующий запрос SQL будет таким

```sql
SELECT * FROM users WHERE (users.activation_code IS NULL) LIMIT 1
```

И это найдет первого пользователя в базе данных, вернет его и войдет под ним. Об этом подробно написано [тут (англ.)](http://www.rorsecurity.info/2007/10/28/restful_authentication-login-security/). _Рекомендовано обновлять свои плагины время от времени_. Более того, можете тестировать свое приложение, чтобы найти больше недостатков, таких как это.

### Брутфорсинг аккаунтов

NOTE: _Брутфорс-атаки на аккаунты это атаки методом проб и ошибок. Отбиться от них можно с помощью обычных сообщений об ошибке и, возможно, требования ввести CAPTCHA._

Перечень имен пользователей вашего веб-приложения может быть использован для брутфорса соответствующих паролей, поскольку большинство людей не используют сложные пароли. Большинство паролей это комбинация слов из словаря и, возможно, цифр. Таким образом, вооруженная перечнем пользователей и словарем, автоматическая программа может подобрать правильный пароль за считанные минуты.

Поэтому большинство приложений отображают общее сообщение об ошибке “неправильное имя пользователя или пароль”, если даже одно из них не правильное. Если оно сообщит “имя пользователя, которое вы ввели, не найдено”, злоумышленник сможет автоматически собрать перечень имен пользователя.

Однако часто разработчики веб приложения пренебрегают страницами восстановления пароля. Эти страницы часто признают, что введенное имя пользователя или адрес e-mail (не) был найден. Это позволяет злоумышленнику собирать перечень имен пользователей и брутфорсить аккаунты.

В целях смягчения таких атак, _отображайте общее сообщение об ошибке и на страницах восстановления пароля_. Более того, можете _требовать ввести CAPTCHA после нескольких проваленных попыток входа с одного  адреса IP_. Отметим, что это не пуленепробиваемая защита против автоматических программ, поскольку эти программы могут изменять свой адрес IP так часто, как нужно. Однако это будет барьером для атаки.

### Взлом аккаунта

Многие веб приложения позволяют легко взломать пользовательские аккаунты. Почему бы не отличиться и не сделать это более трудным?

#### Пароли

Подумайте о ситуации, когда злоумышленник украл куки сессии пользователя и, таким образом, может совместно с ним использовать приложение. Если будет просто сменить пароль, злоумышленник взломает аккаунт в два щелчка. Или, если форма изменения пароля уязвима для CSRF, злоумышленник сможет изменить пароль жертвы, заманив его на веб страницу, на которой содержится тег IMG, осуществляющий CSRF. Как контрмеру _делайте формы изменения пароля безопасными против CSRF_, естественно. И _требуйте от пользователя ввести старый пароль при его изменении_.

#### E-Mail

Однако злоумышленник может также получить контроль над аккаунтом, изменив адрес e-mail. После его изменения, он пойдет на страницу восстановления пароля и (возможно новый) пароль будет выслан на адрес e-mail злоумышленника. В качестве контрмеры _также требуйте от пользователя вводить пароль при изменении адреса e-mail_.

#### Другое

В зависимости от вашего веб приложения, могут быть другие способы взломать аккаунт пользователя. Во многих случаях CSRF и XSS способствуют этому. Как пример, уязвимость CSRF в [Google Mail](http://www.gnucitizen.org/blog/google-gmail-e-mail-hijack-technique/). В этой прототипной атаке жертва могла быть заманена на сайт злоумышленника. На этом сайте создавался тег IMG, который приводил к HTTP запросу GET, который изменял настройки фильтра Google Mail. Если жертва была авторизована на Google Mail, злоумышленник могу изменить фильтры для перенаправления всех писем на его e-mail. Это почти так же вредно, как и полный взлом аккаунта. Как контрмера, _пересмотрите логику своего приложения и устраните все уязвимости XSS и CSRF_.

### CAPTCHA

INFO: _CAPTCHA это тест вызова-ответа для определения, что ответ не создан компьютером. Она часто используется для защиты форм комментирования от автоматических спам-ботов, требуя от пользователя написать буквы на искаженном изображении. Идея отрицательной CAPTCHA не просить пользователей доказать, что они люди, а показать, что робот является роботом._

Но не только спам-роботы (боты) являются проблемой, но и боты автоматической регистрации. Популярной CAPTCHA API является [reCAPTCHA](http://recaptcha.net/), которая отображает два искаженых изображения слов из старых книг. Она также добавляет линию под углом, а не искаженный фон или высокий уровень деформации текста, как делали раньше CAPTCHA, так как они были сломаны. Дополнительно, использование reCAPTCHA помогает оцифровать старые книги. [ReCAPTCHA](http://ambethia.com/recaptcha/) это также плагин Rails с тем же именем, как и API.

Вы получаете два ключа из API, открытый и секретный ключ, которые помещаете в свою среду Rails. После этого можете использовать метод recaptcha_tags во вьюхе и метод verify_recaptcha в контроллере. Verify_recaptcha возвратит false, если валидация провалится. Есть проблема с CAPTCHA, она раздражает. Кроме того, некоторые слабовидящие пользователи найдут искаженные CAPTCHA неудобочитаемыми. Идея отрицательной CAPTCHA не просить пользователя доказать, что он человек, а раскрыть, что спам-робот является ботом.

Большинство ботов реально тупые, они ползают по вебу и кладут свой спам в каждое поле формы, какое только находят. Отрицательная CAPTCHA берет преимущество в этом и включает поле "соблазна" в форму, которое скрыто от человека с помощью CSS или JavaScript.

Вот несколько идей, как спрятать поля соблазна с помощью JavaScript и/или CSS:

* расположить поля за пределами видимой области страницы
* сделать элементы очень маленькими или цветом таким же, как фон страницы
* оставить поля отображаемыми, но сказать людям оставить их пустыми

Наиболее простой отрицательной CAPTCHA является одно скрытое поле соблазна. На серверной стороне проверяется значение поля: если оно содержит текст, значит это бот. Затем можно или игнорировать сообщение, или вернуть положительный результат, но не сохранять сообщение в базу данных. Это, возможно, удовлетворит бота и он пойдет дальше. То же самое можно делать с надоедливыми пользователями.

Более сложные отрицательные CAPTCHA рассмотрены в [блоге Ned Batchelder](http://nedbatchelder.com/text/stopbots.html):

* Включить поле с текущей временной меткой UTC в нем и проверить его на сервере. Если оно слишком близко в прошлом, форма невалидна.
* Рандомизировать имена полей
* Включить более одного поля соблазна всех типов, включая кнопки подтверждения

Отметьте, что это защитит только от автоматических ботов, специально изготовленные боты не могут быть этим остановлены. Поэтому _отрицательная CAPTCHA не может хорошо защитить формы входа_.

### Логирование

WARNING: _Скажите Rails не помещать пароли в файлы логов._

По умолчанию Rails логирует все запросы, сделанные к веб приложению. Но файлы логов могут быть большим вопросом безопасности, поскольку они могут содержать личные данные логина, номера кредитных карт и так далее. При разработке концепции безопасности веб приложения также необходимо думать о том, что случится, если злоумышленник получит (полный) доступ к веб серверу. Шифрование секретных данных и паролей будут совершенно бесполезным, если файлы лога отображают их чистым текстом. Можете _фильтровать некоторые параметры запроса в ваших файлах лога_, присоединив их к `config.filter_parameters` в конфигурации приложения. Эти параметры будут помечены [FILTERED] в логе.

```ruby
config.filter_parameters << :password
```

### Хорошие пароли

INFO: _Думаете, что сложно запомнить все свои пароли? Не записывайте их, а используйте первые буквы каждого слова в легко запоминающее выражение._

Bruce Schneier, технолог по безопасности, [проанализировал](http://www.schneier.com/blog/archives/2006/12/realworld_passw.html) 34,000 имен и паролей реальных пользователей во время фишинговой атаки на MySpace, упомянотой ранее. 20 наиболее распространенных паролей следующие:

password1, abc123, myspace1, password, blink182, qwerty1, fuckyou, 123abc, baseball1, football1, 123456, soccer, monkey1, liverpool1, princess1, jordan23, slipknot1, superman1, iloveyou1, и monkey.

Интересно, что только 4% из этих паролей были словарными словами и абсолютное большинство было буквенно-цифровое. Однако, словари паролей взломщика содержат большое количество современных паролей, и они пробуют все буквенно-цифровые комбинации. Если злоумышленник знает ваше имя пользователя, и вы используете слабый пароль, ваш аккаунт будет легко взломан.

Хороший пароль представляет собой длинную буквенно-цифровую комбинацию в различном регистре. Так как это трудно запомнить, советуется вводить только _первые буквы выражения, которое вы можете легко запомнить_. Например, "The quick brown fox jumps over the lazy dog" будет "Tqbfjotld". Отметьте, что это всего лишь пример, не стоит использовать известные фразы, наподобие этой, так как они могут также появиться в словарях взломщиков.

### Регулярные выражения

INFO: _Распространенная ошибка в регулярных выражениях Ruby в том, что проверяется соответствие начала и конца строки с помощью ^ и $, вместо \A и \z._

Ruby использует немного отличающийся от многих языков программирования подход в соответствии концу и началу строки. Поэтому даже много литературы по Ruby и Rails допускают такую ошибку. Так как же это влияет на безопасность? Скажем, вы хотите по-быстрому проверить поле URL и используете подобное простое регулярное выражение:

```ruby
  /^https?:\/\/[^\n]`$/i
```

В некоторых языках это сработает хорошо. Однако, _в Ruby ^ и $ соответствуют началу и концу *строчки*_. И, таким образом, следующий URL пройдет фильтр без проблем:

```
javascript:exploit_code();/*
http://hi.com
*/
```

Этот URL пройдет фильтр, поскольку он соответствует регулярному выражению – вторая строчка, остальное не имеет значения. Теперь представим, что у нас во вьюхе этот URL выводится следующим образом:

```ruby
  link_to "Homepage", @user.homepage
```

Для посетителя ссылка выглядит невинно, но при ее нажатии, она запустит Javascript функцию "exploit_code" или любой другой представленный злоумышленником скрипт.

Для починки регулярного выражения должны использоваться \A и \z вместо ^ и $, следующим образом:

```ruby
  /\Ahttps?:\/\/[^\n]+\z/i
```

Поскольку это частая ошибка, теперь валидатор формата (validates_format_of) вызывает исключение, если представленное регулярное выражение начинается с ^ или заканчивается на $. Если вам необходимо использовать ^ и $ вместо \A и \z (что является редкостью), можно установить опцию :multiline в true, следующим образом:

```ruby
  # content should include a line "Meanwhile" anywhere in the string
  validates :content, :format => { :with => /^Meanwhile$/, :multiline => true }
```

Отметьте, что это защищает вас только против наиболее распространенной ошибки при использовании валидатора формата - нужно всегда держать в уме, что ^ и $ соответствуют началу и концу **строчки** в Ruby, а не началу и концу строки.

### Расширение привилегий

WARNING:  _Изменение единственного параметра может дать пользователю неавторизованный доступ. Помните, что каждый параметр может быть изменен, не зависимо от того, как вы спрятали или завуалировали его._

Наиболее общий параметр, в который может вмешиваться пользователь, это параметр id, как в `http://www.domain.com/project/1`, где 1 это id. Он будет доступен в params в контроллере. Там вы скорее всего сделаете что-то подобное:

```ruby
@project = Project.find(params[:id])
```

Это нормально для большинства приложений, но безусловно нет, если пользователь не авторизован для просмотра всех проектов. Если пользователь изменяет id на 42, и ему не позволено видеть эту информацию, он в любом случае получит к ней доступ. Вместо этого, _также запрашивайте права доступа пользователя_:

```ruby
@project = @current_user.projects.find(params[:id])
```

В зависимости от вашего веб приложения, может быть много параметров, в которые может вмешиваться пользователь. Как правило, _не вводимые пользователем данные безопасны, пока не доказано обратное, и каждый параметр от пользователя потенциально подтасован_.

Не заблуждайтесь о безопасности при обфускации и безопасности JavaScript. The Web Developer Toolbar для Mozilla Firefox позволяет Вам предварительно смотреть и изменять каждые скрытые поля формы. _JavaScript может использоваться для проверки пользовательских данных, но только не для предотвращения злоумышленников от отсылки злонамеренных запросов с неожидаемыми значениями_. Плагин The Live Http Headers для Mozilla Firefox логирует каждый запрос и может повторить и изменить его. Это простой способ обойти любые валидации JavaScript. А еще есть даже прокси на стороне клиента, которые позволяют перехватывать любой запрос и отклик из Интернет.
