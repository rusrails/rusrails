# Подделка межсайтовых запросов (CSRF)

Этот метод атаки работает через включение вредоносного кода или ссылки на страницу, которая обращается к веб приложению, на котором предполагается, что пользователь аутентифицирован. Если сессия для того веб приложения не истекла, злоумышленник сможет выполнить несанкционированные команды.

![csrf](/assets/guides/csrf.png)

В [главе про сессии](/ruby-on-rails-security-guide/sessions) мы узнали, что большинство приложений на Rails используют сессии, основанные на куки. Либо они хранят id сессии в куки и имеют хэш сессии на сервере, либо весь хэш сессии на клиенте. В любом случае, браузер автоматически пошлет куки с каждым запросом к домену, если он найдет куки для этого домена. Спорный момент в том, что он также пошлет куки, если запрос идет с сайта другого домена. Давайте рассмотрим пример:

* Bob просматривает доску объявлений и смотрит публикацию от хакера, в котором имеется созданный HTML элемент изображения. Элемент ссылается на команду в приложении Bob'а по управлению проектами, а не на файл изображения.
* `<img src="http://www.webapp.com/project/1/destroy">`
* Сессия Bob'а на www.webapp.com все еще действующая, так как он работал с сайтом несколько минут назад.
* Просматривая публикацию, браузер находит тег изображения. Он пытается загрузить предполагаемое изображения с сайта www.webapp.com. Как уже объяснялось, он также посылает куки с валидным id сессии.
* Веб приложение www.webapp.com подтверждает информацию о пользователе в соответствующей сессии и уничтожает проект с ID 1. Затем он возвращает итоговую страницу, которая не является ожидаемым результатом для браузера, поэтому он не отображает изображение.
* Bob не уведомляется об атаке - но несколько дней спустя он обнаруживает, что проекта номер один больше нет.

Важно отметить, что фактически создаваемое изображение или ссылка не обязательно должны быть расположены в домене веб приложения, они могут быть где угодно – на форуме, в публикации блога или в email.

CSRF очень редко появляется среди CVE (распространённых уязвимостей и опасностей) -- менее 0.1% в 2006 -- но на самом деле это "спящий гигант". _CSRF это важный вопрос безопасности_.

### Контрмеры CSRF

NOTE: _Во-первых, как это требуется W3C, используйте надлежащим образом GET и POST. Во-вторых, токен безопасности в не-GET запросах защитит ваше приложение от CSRF._

Протокол HTTP в основном представляет два основных типа запросов - GET и POST (их больше, но не все они поддерживаются некоторыми браузерами). Консорциум Всемирной паутины (W3C) предоставляет контрольный список для выбора между HTTP методами GET или POST:

**Используйте GET, если:**

* Взаимодействие более _похоже на вопрос_ (например, это безопасная операция, такая как запрос, операция чтения или поиска).

**Используйте POST, если:**

* Взаимодействие более _похоже на распоряжение_, или
* Взаимодействие _изменяет состояние_ ресурса способом, который пользователь будет ощущать (например, подписка на услугу), или
* Пользователь _несет ответственность за результат_ взаимодействия.

Если Ваше приложение является RESTful, можете использовать дополнительные методы HTTP, такие как PUT или DELETE. Однако, большинство современных веб браузеров не поддерживают их - только GET и POST. Rails использует скрытое поле `_method` для преодоления этого препятствия.

_Запросы POST также могут быть посланы автоматически_. Вот пример для ссылки, которая отображает www.harmless.com как назначение в статусбаре браузера. Фактически она динамически создает новую форму, посылающую запрос POST.

```html
<a href="http://www.harmless.com/" onclick="
  var f = document.createElement('form');
  f.style.display = 'none';
  this.parentNode.appendChild(f);
  f.method = 'POST';
  f.action = 'http://www.example.com/account/destroy';
  f.submit();
  return false;">To the harmless survey</a>
```

Или злоумышленник поместит код в обработчик события onmouseover изображения:

```html
<img src="http://www.harmless.com/img" width="400" height="400" onmouseover="..." />
```

Имеется множество других возможностей, включая Ajax для атаки жертвы в фоновом режиме. _Решение состоит во включении токена безопасности в не-GET запросы,_ который проверяется на серверной стороне. В Rails 2 или выше, это одна строка в контроллере приложения:

```ruby
protect_from_forgery :secret => "123456789012345678901234567890..."
```

Это автоматически включит токен безопасности, вычисленный из текущей сессии и секретного ключа сервера, во все формы и запросы Ajax, создаваемые Rails. Не нужно указывать secret, если используете CookieStorage как хранилище сессии. Если токен безопасности не будет соответствовать ожидаемому, сессия будет перезагружена. В версиях Rails до 3.0.4 это вызывало ошибку ActionController::InvalidAuthenticityToken.

Является обычной практикой использование постоянных куки для хранения пользовательской информации, к примеру с помощью `cookies.permanent`. В этом случае куки не будут очищены и встроенная защита от CSRF не будет эффективна. Если для этой информации вы используете хранилище куки иное, чем сессия, то должны указать, что делать, самостоятельно:

```ruby
def handle_unverified_request
  super
  sign_out_user # Example method that will destroy the user cookies.
end
```

Вышеуказанный метод должен быть помещен в `ApplicationController` и вызываться, когда отсутствует токен CSRF для не-GET запроса.

Отметьте, что _уязвимости межсайтового скриптинга (XSS) обходят все защиты от CSRF_. XSS дает злоумышленнику доступ ко всем элементам на странице, поэтому он может прочитать токен безопасности CSRF из формы или непосредственно утвердить форму. Читайте [более подробно о XSS](/ruby-on-rails-security-guide/injection#cross-site-scripting-xss) позже.
