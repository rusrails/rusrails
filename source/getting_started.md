Rails для начинающих
====================

Это руководство раскрывает установку и запуск Ruby on Rails.

После его прочтения, вы узнаете:

* Как установить Rails, создать новое приложение на Rails и присоединенить ваше приложение к базе данных.
* Общую структуру приложения на Rails.
* Основные принципы MVC (Model, View Controller - «Модель-представление-контроллер») и дизайна, основанного на RESTful.
* Как быстро создать изначальный код приложения на Rails.

Допущения в этом руководстве
----------------------------

Это руководство рассчитано на новичков, которые хотят запустить приложение на Rails с нуля. Оно не предполагает, что вы раньше работали с Rails. Однако, чтобы полноценно им воспользоваться, необходимо предварительно установить:

* Язык [Ruby](http://www.ruby-lang.org/en/downloads версии 1.9.3) или новее
* Систему пакетов [RubyGems](http://rubygems.org/)
    * Чтобы узнать больше о RubyGems, прочитайте [RubyGems User Guide](http://docs.rubygems.org/read/book/1)
* Установленную [базу данных SQLite3](http://www.sqlite.org)

Rails – фреймворк для веб-разработки, написанный на языке программирования Ruby. Если у вас нет опыта в Ruby, возможно вам будет тяжело сразу приступить к изучению Rails. Есть несколько хороших англоязычных ресурсов, посвященных изучению Ruby, например:

* [Mr. Neighborly's Humble Little Ruby Book](http://www.humblelittlerubybook.com)
* [Programming Ruby](http://www.ruby-doc.org/docs/ProgrammingRuby/)
* [Why's (Poignant) Guide to Ruby](http://mislav.uniqpath.com/poignant-guide/)

Из русскоязычных ресурсов, посвященных изучению Ruby, я бы выделил следующие:

* [Викиучебник по Ruby](http://ru.wikibooks.org/wiki/Ruby)
* [Руководство по Руби на 1 странице](http://www.linuxshare.ru/docs/devel/languages/ruby/ruby.html)
* [Учебник 'Учись программировать', автор Крис Пайн](http://www.shokhirev.com/mikhail/ruby/ltp/title.html)

Что такое Rails?
----------------

Rails - фреймворк для веб-разработки, написанный на языке программирования Ruby. Он разработан, чтобы сделать программирование веб-приложений проще, так как использует ряд допущений о том, что нужно каждому разработчику для создания нового проекта. Он позволяет вам писать меньше кода в процессе программирования, в сравнении с другими языками и фреймворками. Профессиональные разработчики на Rails также отмечают, что с ним разработка веб-приложений более забавна =)

Rails - своевольный программный продукт. Он делает предположение, что имеется "лучший" способ что-то сделать, и он так разработан, что стимулирует этот способ - а в некоторых случаях даже препятствует альтернативам. Если изучите "The Rails Way", то, возможно, откроете в себе значительное увеличение производительности. Если будете упорствовать и переносить старые привычки с других языков в разработку на Rails, и попытаетесь использовать шаблоны, изученные где-то еще, ваш опыт разработки будет менее счастливым.

Философия Rails включает два важных ведущих принципов:

* DRY - "Don’t Repeat Yourself" -  означает, что написание одного и того же кода в разных местах - это плохо.
* Convention Over Configuration - означает, что Rails сам знает, что вы хотите и что собираетесь делать, вместо того, чтобы заставлять вас по мелочам править многочисленные конфигурационные файлы.

Создание нового проекта Rails
-----------------------------

Лучший способ использования этого руководства - проходить каждый шаг и смотреть, что получится, пропустите код или шаг и учебное приложение не заработает, поэтому следует буквально все делать шаг за шагом. Можно получить законченный код [здесь](https://github.com/lifo/docrails/tree/master/guides/code/getting_started).

Следуя этому руководству, вы создадите проект Rails с названием `blog`, очень простой веб-блог. Прежде чем начнем создавать приложение, нужно убедиться, что сам Rails установлен.

TIP: Нижеследующие примеры используют # и $ для обозначения строки ввода терминала суперпользователя и обычного пользователя соответственно в UNIX-подобных операционных системах. Если вы используете Windows, ваша строка будет выглядеть наподобие c:\source_code>

### Установка Rails

Откройте приложения для командной строки. На Mac OS X откройте Terminal.app, на Windows выберите "Run" в меню Start и напишите 'cmd.exe'. Любые команды, начинающиеся со знака доллара `$` должны быть запущены в командной строке. Убедитесь, что у вас установлена текущая версия Ruby:

```bash
$ ruby -v
ruby 1.9.3p385
```

Для установки Rails используйте команду `gem install`, представленную RubyGems:

```bash
$ gem install rails
```

TIP. Существует ряд инструментов для помощи в быстрой установке Ruby и Ruby on Rails в вашей системе. Пользователи Windows могут использовать [Rails Installer](http://railsinstaller.org), а пользователи Mac OS X могут использовать [Rails One Click](http://railsoneclick.com).

Чтобы проверить, что все установлено верно, нужно выполнить следующее:

```bash
$ rails --version
```

Если выводится что-то вроде "Rails 4.0.0", можно продолжать.

### Создание приложения Blog

Rails поставляется с рядом скриптов, названных генераторами, разработанных для облегчения жизни разработчика, создавая все, что необходимо для начала работы над определенной задачей. Одним из них является генератор нового приложения, предоставляющий вам основу приложения Rails, таким образом, вам не нужно писать его самим.

Для использования этого генератора, откройте терминал, войдите в папку, в которой у вас есть права на создание файлов и напишите:

```bash
$ rails new blog
```

Это создаст приложение на Rails с именем Blog в директории blog и установит гемы, зависимости от которых упомянуты в `Gemfile` при использовании `bundle install`.

TIP: Можно посмотреть все возможные опции командной строки, которые принимает билдер приложения на Rails, запустив `rails new -h`.

После того, как вы создали приложение blog, перейдите в его папку, чтобы продолжить работу непосредственно с этим приложением:

```bash
$ cd blog
```

Команда 'rails new blog', запущенная ранее, создаст папку в вашей рабочей директории, названную `blog`. В директории `blog` имеется несколько автоматически созданных файлов и папок, задающих структуру приложения на Rails. Большая часть работы в этом самоучителе будет происходить в папке `app/`, но сейчас пробежимся по функциям каждой папки, которые создает Rails в новом приложении по умолчанию:

| Файл/Папка              | Назначение |
| ----------------------- | ---------- |
|app/                     |Содержит контроллеры, модели, вьюхи, хелперы, рассыльщики и ресурсы вашего приложения. Мы рассмотрим эту папку подробнее далее.|
|bin/                     |Содержит Rails скрипты которые стартуют ваше приложение, также директория может содержать другие скрипты которые вы используете для деплоя или запуска.|
|config/                  |Конфигурации правил, маршрутов, базы данных вашего приложения, и т.д. Более подробно это раскрыто в [Конфигурирование приложений на Rails](/configuring-rails-applications)|
|config.ru                |Конфигурация Rack для серверов, основанных на Rack, используемых для запуска приложения.|
|db/                      |Содержит текущую схему вашей базы данных, а также миграции базы данных.|
|Gemfile<br />Gemfile.lock|Эти файлы позволяет определить, какие нужны зависимости от гемов для вашего приложения на Rails. Эти файлы используются гемом Bundler. Подробнее о Bundler смотрите на [сайте Bundler](http://gembundler.com)|
|lib/                     |Внешние модули для вашего приложения.|
|log/                     |Файлы логов приложения.|
|public/                  |Единственная папка, которая доступна извне как есть. Содержит статичные файлы и скомпилированные ресурсы.|
|Rakefile                 |Этот файл содержит набор команд, которые могут быть запущены в командной строке. Определения команд производятся во всех компонентах Rails. Вместо изменения Rakefile, вы можете добавить свои собственные задачи, добавив файлы в директорию lib/tasks вашего приложения.|
|README.rdoc              |Это вводный мануал для вашего приложения. Его следует отредактировать, чтобы рассказать остальным, что ваше приложение делает, как его настроить, и т.п.|
|test/                    |Юнит-тесты, фикстуры и прочий аппарат тестирования. Это раскрывается в руководстве [Тестирование приложений на Rails](/a-guide-to-testing-rails-applications)|
|tmp/                     |Временные файлы (такие как файлы кэша, pid и сессии)|
|vendor/                  |Место для кода внешних разработчиков. В типичном приложении на Rails, включает Ruby Gems и исходный код Rails (если вы опционально установили его в свой проект).|

Hello, Rails!
-------------

Для начала, давайте выведем на экран какой-либо текст. Для этого нужен запущенный сервер вашего приложения на Rails.

### Запуск веб-сервера

Фактически у вас уже есть функциональное приложение на Rails. Чтобы убедиться, нужно запустить веб-сервер на вашей машине. Это можно осуществить, запустив:

```bash
$ rails server
```

TIP: Компилирование CoffeeScript в JavaScript требует JavaScript runtime, и его отсутствие приведет к ошибке `execjs`. Обычно Mac OS X и Windows поставляются с установленным JavaScript runtime. Rails добавляет гем `therubyracer` в Gemfile нового приложения в закомментированной строке, если нужно, можете ее раскомментировать. `therubyrhino` - рекомендованный runtime для пользователей JRuby, он добавляется в Gemfile, если приложение создаётся под JRuby. Можно узнать все о поддерживаемых runtime-ах в [ExecJS](https://github.com/sstephenson/execjs#readme)

Это запустит WEBrick, веб-сервер, встроенный в Ruby по умолчанию. Чтобы увидеть приложение в действии, откройте окно браузера и пройдите по адресу <http://localhost:3000>. Вы должны увидеть дефолтную информационную страницу Rails:

![скриншот Welcome Aboard](/assets/guides/rails_welcome30.png)

TIP: Для остановки веб-сервера нажмите Ctrl+C в терминале, где он запущен. Чтобы убедиться в том, что сервер был остановлен, вы должны снова увидеть  курсор командной строки. Для большинства UNIX-подобных систем, включая Mac OS X, это будет знак доллара `$`. В режиме development, Rails в основном не требует остановки сервера; все изменения, которые Вы делаете в файлах, автоматически подхватываются сервером.

Страница "Welcome Aboard" это своеобразный тест для нового приложения на Rails: она показывает, что ваши программы настроены достаточно правильно для отображения страницы. Также можете нажать по ссылке _About your application’s environment_ чтобы увидеть сводку о среде вашего приложения.

### Скажите "привет", Рельсы

Чтобы Rails сказал "Привет", нужно создать, как минимум, _контроллер_ и _вьюху_.

Назначением контроллера является получение определенных запросов к приложению. _Роутинг_ решает, какой контроллер получит какие запросы. Часто имеется более одного маршрута к каждому контроллеру, и различные маршруты могут быть обработаны различными _экшнами_. Назначением каждого экшна является сбор информации для предоставления ее во вьюху.

Назначением вьюхи (представления) является отображение этой информации в удобочитаемом формате. Необходимо отметить важное различие, что местом, в котором собирается информация, является _контроллер_, а не вьюха. Вьюха должна только лишь отображать эту информацию. По умолчанию шаблоны вьюх пишутся на языке названном ERB (Embedded Ruby), который конвертируется циклом запросов в Rails до отправки пользователю.

Для создания нового контроллера, нужно запустить генератор "controller" и сказать ему, что вы хотите контроллер с именем "welcome" с экшном по имени "index", вот так:

```bash
$ rails generate controller welcome index
```

Rails создаст несколько файлов и маршрут.

```bash
create  app/controllers/welcome_controller.rb
 route  get "welcome/index"
invoke  erb
create    app/views/welcome
create    app/views/welcome/index.html.erb
invoke  test_unit
create    test/controllers/welcome_controller_test.rb
invoke  helper
create    app/helpers/welcome_helper.rb
invoke    test_unit
create      test/helpers/welcome_helper_test.rb
invoke  assets
invoke    coffee
create      app/assets/javascripts/welcome.js.coffee
invoke    scss
create      app/assets/stylesheets/welcome.css.scss
```

Наиболее важными из них являются, разумеется, контроллер, расположенный в `app/controllers/welcome_controller.rb`, и вьюха, расположенная в `app/views/welcome/index.html.erb`.

Откройте файл `app/views/welcome/index.html.erb` в текстовом редакторе. Удалите весь существующий в файле код и замените его на следующую единственную строчку кода:

```html
<h1>Hello, Rails!</h1>
```

### Настройка домашней страницы приложения

Теперь, когда мы сделали контроллер и вьюху, нужно сказать Rails, что мы хотим увидеть "Hello Rails!". В нашем случае мы хотим это увидеть, когда зайдем в корневой URL нашего сайта, <http://localhost:3000>. Однако сейчас это место заняла тестовая страница "Welcome Aboard".

Чтобы это исправить, удалите файл `index.html`, расположенный в директории `public` приложения.

Так нужно сделать, так как Rails отдаст любой статичный файл из директории `public`, соответствующий маршруту, предпочтя его любому динамическому содержимому, создаваемому из контроллеров. Файл `index.html` особенный: он будет отдан, если запрос придет в корневой маршрут, т.е. http://localhost:3000. Если произойдет другой запрос, такой как http://localhost:3000/welcome, будет отдан файл `public/welcome.html`, но только если он существует.

Теперь нужно сказать Rails, где находится настоящая домашняя страница.

Откройте файл `config/routes.rb` в редакторе.

```ruby
Blog::Application.routes.draw do
  get "welcome/index"

  # The priority is based upon order of creation:
  # first created -> highest priority.
  # ...
  # You can have the root of your site routed with "root"
  # root to: "welcome#index"
```

Это _маршрутный файл_ вашего приложения, который содержит варианты входа на сайт на специальном языке DSL (domain-specific language, предметно-ориентированный язык программирования), который говорит Rails, как соединять входящие запросы с контроллерами и экшнами. Этот файл содержит много закомментированных строк с примерами, и один из них фактически показывает, как соединить корень сайта с определенным контроллером и экшном. Найдите строку, начинающуюся с `root :to` и раскоментируйте ее. Должно получится следующее:

```ruby
root to: "welcome#index"
```

`root to: "welcome#index"` говорит Rails направить запросы к корню приложения в экшн index контроллера welcome, а `get "welcome/index"` говорит Rails направлять запросы к <http://localhost:3000/welcome/index> в экшн index контроллера welcome. Он был создан ранее при запуске генератора контроллера (`rails generate controller welcome index`).

Теперь, если вы пройдете по адресу <http://localhost:3000> в браузере, то увидите надпись `Hello, Rails!`, которую вы поместили в  `app/views/welcome/index.html.erb`, показывающую, что этот новый маршрут действительно ведет в экшн `index` в `WelcomeController`, и вьюха корректно рендерится.

TIP. Чтобы узнать больше о роутинге, обратитесь к руководству [Роутинг в Rails](/rails-routing).

Разрабатываем быстро
--------------------

После того, как вы увидели, как создать контроллер, экшн и вьюху, давайте создадим что-то более вещественное.

Теперь в приложении Blog, мы создадим новый _ресурс_. Ресурс - это термин, обозначающий коллекцию схожих объектов, таких как публикации, люди или животные. Можно создавать, читать, обновлять и уничтожать элементы для ресурса, и эти операции называются операциями _CRUD_ (create, read, update, destroy).

Rails представляет метод `resources`, который используется для объявления стандартного ресурса REST. Вот как будет выглядеть `config/routes.rb`.

```ruby
Blog::Application.routes.draw do

  resources :posts

  root to: "welcome#index"
end
```

Если запустить `rake routes`, можно увидеть все маршруты для стандартных действий RESTful.

```bash
$ rake routes
    posts GET    /posts(.:format)          posts#index
          POST   /posts(.:format)          posts#create
 new_post GET    /posts/new(.:format)      posts#new
edit_post GET    /posts/:id/edit(.:format) posts#edit
     post GET    /posts/:id(.:format)      posts#show
          PATCH  /posts/:id(.:format)      posts#update
          PUT    /posts/:id(.:format)      posts#update
          DELETE /posts/:id(.:format)      posts#destroy
     root        /                         welcome#index
```

В следующем разделе мы добавим возможность создания новых публикаций, и сможем просматривать их. Это буквы "C" и "R" из CRUD: creation и reading. Форма для этого будет выглядеть так:

![Форма новой публикации](/assets/guides/getting_started/new_post.png)

Она выглядит немного просто сейчас, но это нормально. Позже мы увидим, как улучшить ее внешний вид.

### Основы

Первая вещь, которую нам нужно сделать, это создать новую публикацию. Наиболее подходящим местом будет `/posts/new`. С уже определенным маршрутом уже можно осуществлять запросы к `/posts/new` приложения. Перейдите на <http://localhost:3000/posts/new> и вы увидите ошибку маршрутизации:

![Другая ошибка роутинга, uninitialized constant PostsController](/assets/guides/getting_started/routing_error_no_controller.png)

Эта ошибка произошла, поскольку маршрут нуждается в определенном контроллере, чтобы обслужить запрос. Решение этой проблемы простое: нужно создать контроллер с именем `PostsController`. Это будет сделано запуском команды:

```bash
$ rails g controller posts
```

Если открыть только что созданный `app/controllers/posts_controller.rb`, можно увидеть абсолютно пустой контроллер:

```ruby
class PostsController < ApplicationController
end
```

Контроллер - это просто класс, унаследованный от `ApplicationController`. В этом классе вы определить методы, которые станут экшнами для этого контроллера. Эти экшны будут выполнять операции CRUD с публикациями в вашей системе.


Если теперь обновить <http://localhost:3000/posts/new>, вы увидите новую ошибку:

![Unknown action new for PostsController!](/assets/guides/getting_started/unknown_action_new_for_posts.png)

Эта ошибка показывает, что Rails не может найти экшн `new` внутри `PostsController`, который был только что создан. Это так, поскольку контроллеры в Rails при создании пустые по умолчанию, если вы не указали желаемые экшны при процессе генерации.

Чтобы вручную определить экшн в контроллере, все что нужно - это определить в нем новый метод. Откройте `app/controllers/posts_controller.rb` и в классе `PostsController` определите метод `new`:

```ruby
def new
end
```

С методом `new`, определенным в `PostsController`, если обновите <http://localhost:3000/posts/new>, увидите другую ошибку:

![Template is missing for posts/new](/assets/guides/getting_started/template_is_missing_posts_new.png)

Вы получили эту ошибку, поскольку Rails ожидает, что обычные экшны, такие как этот, имеют связанные с ними вьюхи для отображения их информации. Когда нет доступных вьюх, Rails выдает ошибку.

В вышеприведенном изображении конец строки был обрезан. Давайте посмотрим на полный текст:

<blockquote>
Missing template posts/new, application/new with {locale:[:en], formats:[:html], handlers:[:erb, :builder, :coffee]}. Searched in: * "/path/to/blog/app/views"
</blockquote>

Как много букв! Давайте быстро пробежимся и поймем, что означает каждая часть.

Первая часть указывает, какой шаблон отсутствует. В нашем случае, шаблон `posts/new`. Rails сперва ищет этот шаблон. Если не находит, он пытается загрузить шаблон с именем `application/new`. Он так ищет, поскольку `PostsController` унаследован от `ApplicationController`.

Следующая часть сообщения содержит хэш. Ключ `:locale` в этом хэше просто показывает, на каком языке должен быть получен шаблон. По умолчанию это английский шаблон - или "en". Следующий ключ `:formats` определяет формат шаблона для отдачи в отклик. Формат по умолчанию `:html`, таким образом, Rails ищет шаблон HTML. Последний ключ, `:handlers`, говорит нам, что для рендеринга нашего шаблона могут быть использованы _обработчики шаблон_. `:erb` в основном используется для шаблонов HTML, `:builder` используется для шаблонов XML, и `:coffee` использует CoffeeScript для создания шаблонов JavaScript.

Заключительная часть этого сообщения говорит нам, где Rails искал шаблоны. Шаблоны в простом приложении Rails, таком как наше, содержатся в одном месте, но в более сложных приложениях, они могут находиться в разных местах.

Простейшим шаблоном, работающим в данном случае, будет расположенный в `app/views/posts/new.html.erb`. Расширение этого файла является ключом: первое расширение это _формат_ шаблона, а второе расширение это _обработчик_, который будет использован. Rails пытается найти шаблон с именем `posts/new` в `app/views` приложения. Форматом для этого шаблона может быть только `html`, а обработчиком должен быть один из `erb`, `builder` или `coffee`. Поскольу мы хотим создать новую форму HTML, будем использовать язык `ERB`. Следовательно, файл должен называться `posts/new.html.erb`, и должен быть расположен в директории `app/views` приложения.

Создайте новый файл `app/views/posts/new.html.erb` и поместите в него:

```html
<h1>New Post</h1>
```

Теперь при обновлении <http://localhost:3000/posts/new> вы увидите, что у страницы появился заголовок. Теперь маршрут, контроллер, экшн и вьюха гармонично работают. Время создать форму для новой публикации.

### Первая форма

Для создания формы в этом шаблоне, мы будем использовать <em>form builder</em>. Основной form builder для Rails представлен методом хелпера по имени `form_for`. Для использования этого метода добавьте код в `app/views/posts/new.html.erb`:

```html+erb
<%= form_for :post do |f| %>
  <p>
    <%= f.label :title %><br>
    <%= f.text_field :title %>
  </p>

  <p>
    <%= f.label :text %><br>
    <%= f.text_area :text %>
  </p>

  <p>
    <%= f.submit %>
  </p>
<% end %>
```

Если теперь обновить страницу, вы увидите точно такую форму как в начале примера. Создание форм в Rails, действительно, очень простое!

При вызове `form_for`, вы передали в него определяющий объект для этой формы. В нашем случае это символ `:post`. Это сообщает хелперу `form_for`, для чего эта форма. Внутри блока для этого метода, объект `FormBuilder` - представленный как `f` - используется для создания двух меток и двух текстовых полей, по одному для заголовка и текста публикации. Наконец, вызов `submit` на объекте `f` создаст кнопку отправки формы.

Хотя, у этой формы есть одна проблема. Если посмотрите на созданный HTML, просмотрев исходник страницы, то увидите у формы атрибут `action`, указывающий на `/posts/new`. Это проблема, поскольку этот маршрут ведет на ту же самую страницу, и этот маршрут должен использоваться только для отображения формы для новой публикации.

Форме нужно использовать иной URL, чтобы вести куда-то еще. Это можно быстро сделать с помощью опции `:url` для `form_for`. Обычно в Rails, экшн, используемый для подтверждения формы new, такой как эта, называется "create", поэтому форма должна указывать на этот экшн.

Отредактируйте строчку `form_for` в `app/views/posts/new.html.erb` следующим образом:

```html+erb
<%= form_for :post, url: posts_path do |f| %>
```

В этом примере в опцию `:url` передан хелпер `posts_path`. С помощью него Rails укажет форме на экшн `create` текщего контроллера, `PostsController`, и пошлет запрос `POST` по этому маршруту.

При использовании метода `post` вместо метода `get`, Rails определит маршрут, отвечающий только на методы POST. Метод POST является обычным методом, используемым формами во всем вебе.

С определенными формой и ее связанным маршрутом, можно заполнить форму и нажать на кнопку отправки, чтобы начать процесс создания новой публикации, поэтому идите и сделайте это. При отправке формы вы увидите знакомую ошибку:

![Unknown action create for PostsController](/assets/guides/getting_started/unknown_action_create_for_posts.png)

Чтобы это заработало, нужно создать экшн `create` в `PostsController`.

### Создание публикаций

Чтобы убрать "Unknown action", нужно определить экшн `create` в классе `PostsController` в `app/controllers/posts_controller.rb`, ниже экшна `new`:

```ruby
class PostsController < ApplicationController
  def new
  end

  def create
  end
end
```

Если теперь переотправить форму, вы увидите другую знакомую ошибку: отсутствует шаблон. Это нормально, сейчас это можно проигнорировать. Экшн `create` должен только сохранять нашу публикацию в базу данных.

При отправке формы, ее поля будут посланы в Rails как _параметры_. К этим параметрам можно обратиться из экшнов контроллера, как правило, для выполнения определенных задач. Чтобы увидеть, на что похожи эти параметры, измените экшн `create` так:

```ruby
def create
  render text: params[:post].inspect
end
```

Тут метод `render` принимает очень простой хэш с ключом `text` и значением `params[:post].inspect`. Метод `params` это объект, представляющий параметры (или поля), приходящие от формы. Метод `params` возвращает объект `ActiveSupport::HashWithIndifferentAccess`, позволяющий получать доступ к ключам хэша с использованием или строк, или символов. В этой ситуации имеют значение только параметры, пришедшие от формы.

Если еще раз переотправить форму, вы больше не увидите ошибку об отсутствующем шаблоне. Вместо этого вы увидите что-то вроде следующего:

```ruby
{"title"=>"First post!", "text"=>"This is my first post."}
```

Теперь этот экшн отображает параметры для публикации, пришедшие из формы. Однако, это все еще бесполезно. Да, вы видете параметры, но по сути ничего не делаете с ними.

### Создание модели Post

Модели в Rails используют имя в единственном числе, а их соответствующая таблица в базе данных - имя во множественном числе. Rails предоставляет генератор для создания моделей, которым пользуются большинство разработчиков на Rails для создания новых моделей. Для создания новой модели, запустите эту команду в своем терминале:

```bash
$ rails generate model Post title:string text:text
```

С помощью этой команды мы сообщаем Rails что хотим модель `Post` с атрибутом _title_ строкового типа и атрибутом _text_ текстового типа. Эти атрибуты автоматически добавятся в таблицу `posts` и привяжутся к модели `Post`.

Rails в ответ создаст ряд файлов. Сейчас нам интересны только `app/models/post.rb` и `db/migrate/20120419084633_create_posts.rb` (у вас имя может немного отличаться). Последний ответственен за создание структуры базы данных, поэтому мы и рассмотрим его далее.

TIP: Active Record достаточно сообразителен, чтобы автоматически связать имена столбцов с атрибутами модели, что означает, что внутри моделей Rails не нужно объявлять атрибуты, Active Record сделает это автоматически.

### Запуск миграции

Как вы уже видели, `rails generate model` создал файл _миграции базы данных_ в директории `db/migrate`. Миграции - это класс Ruby, разработанный для того, чтобы было просто создавать и модифицировать таблицы базы данных. Rails использует команды rake для запуска миграций, и возможна отмена миграции после того, как она была применена к вашей базе данных. Имя файла миграции включает временную метку, чтобы быть уверенным, что они выполняются в той последовательности, в которой они создавались.

Если Вы заглянете в файл `db/migrate/20120419084633_create_posts.rb` (помните, у вас файл имеет немного другое имя), вот что там обнаружите:

```ruby
class CreatePosts < ActiveRecord::Migration
  def change
    create_table :posts do |t|
      t.string :title
      t.text :text

      t.timestamps
    end
  end
end
```

Эта миграция создает метод `change`, вызываемый при запуске этой миграции. Действие, определенное в этой миграции, также является обратимым, что означает, что Rails знает, как отменить изменения, сделанные этой миграцией, в случае, если вы решите их отменить позже. Когда вы запустите эту миграцию, она создаст таблицу `posts` со строковым столбцом и текстовым столбцом. Она также создаст два поля временных меток для отслеживания времени создания и обновления публикации.

TIP: Для подробностей о миграциях Rails обратитесь к руководству [Миграции базы данных Rails](/rails-database-migrations).

Сейчас нам нужно использовать команду rake, чтобы запустить миграцию:

```bash
$ rake db:migrate
```

Rails запустит эту команду миграции и сообщит, что он создал таблицу Posts.

```bash
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -> 0.0019s
==  CreatePosts: migrated (0.0020s) ===========================================
```

NOTE. Так как вы работаете по умолчанию в среде development, эта команда будет применена к базе данных, определенной в секции `development` вашего файла `config/database.yml`. Если хотите запустить миграции в другой среде, например в production, следует явно передать ее при вызове команды: `rake db:migrate RAILS_ENV=production`.

### Сохранение данных в контроллере

Возвратимся к `posts_controller`, нам нужно изменить экшн `create`, чтобы использовать новую модель `Post` для сохранения данных в базе данных. Откройте `app/controllers/posts_controller.rb` и измените экшн `create` следующим образом:

```ruby
def create
  @post = Post.new(params[:post])

  @post.save
  redirect_to @post
end
```

Вот что тут происходит: каждая модель Rails может быть инициализирована с помощью соответствующих атрибутов, которые будут автоматически привязаны к соответствующим столбцам базы данных. В первой строчке мы как раз это и делаем (помните, что `params[:post]` содержит интересующие нас атрибуты). Затем `@post.save` ответственен за сохранение модели в базу данных. Наконец, мы перенаправляем пользователя на экшн `show`, который мы определим позже.

TIP: Как мы увидим далее, `@post.save` возвращает булево значение, показывающее, была ли сохранена модель, или нет.

### Отображение публикаций

Если снова отправить форму, Rails сообщит о ненайденом экшне `show`. Нам это уже не нужно, поэтому давайте добавим экшн `show` до того.

```ruby
post GET    /posts/:id(.:format)      posts#show
```

Специальный синтаксис `:id` сообщит rails, что этот маршрут ожидает параметр `:id`, который в нашем случае будет идентификатором публикации.

Как и раньше, нам необходим экшн `show` в `app/controllers/posts_controller.rb` и его соответствующая вьюха.

```ruby
def show
  @post = Post.find(params[:id])
end
```

Нужно отметить несколько вещей. Мы использовали `Post.find` для поиска публикации, в которой мы заинтересованы. Также мы использовали переменную экземпляра (с префиксом `@`) для хранения ссылки на объект публикации. Мы сделали так, потому что Rails передаст все переменные экземпляра во вьюху.

Теперь создайте новый файл `app/views/posts/show.html.erb` со следующим содержимым:

```html+erb
<p>
  <strong>Title:</strong>
  <%= @post.title %>
</p>

<p>
  <strong>Text:</strong>
  <%= @post.text %>
</p>
```

Если теперь перейти на <http://localhost:3000/posts/new>, вы **почти** сможете создать новую публикацию. Попробуйте! Вы должны получить ошибку, которая выглядит так:

![Forbidden attributes for new post](/assets/guides/getting_started/forbidden_attributes_for_new_post.png)

В Rails имеется несколько особенностей безопасности, позволяющих написать безопасное приложение, и вы столкнулись с одной из них. Она называется
'strong_parameters', что требует от нас сказать Rails, какие именно параметры мы хотим принимать в наших контроллерах. В этом случае мы хотим разрешить параметры 'title' и 'text', поэтому измените экшн `create` контроллера на следующее:

```
  def create
    @post = Post.new(params[:post].permit(:title, :text))

    @post.save
    redirect_to @post
  end
```

Видите `permit`? Он позволяет принимать `title` и `text` в этом экшне. Стаким изменением, вы, наконец, сможете создать новую публикацию.
Посетите <http://localhost:3000/posts/new> и попробуйте!

![Show action for posts](/assets/guides/getting_started/show_action_for_posts.png)

### Отображение всех публикаций

Нам все еще нужен способ для отображения списка всех наших публикаций, давайте сделаем его. Нам нужен маршрут, помещенный в `config/routes.rb`:

```ruby
posts GET    /posts(.:format)          posts#index
```

И экшн для этого маршрута внутри `PostsController` в файле `app/controllers/posts_controller.rb`:

```ruby
def index
  @posts = Post.all
end
```

И, наконец, вьюха для этого экшна, расположенная в `app/views/posts/index.html.erb`:

```html+erb
<h1>Listing posts</h1>

<table>
  <tr>
    <th>Title</th>
    <th>Text</th>
  </tr>

  <% @posts.each do |post| %>
    <tr>
      <td><%= post.title %></td>
      <td><%= post.text %></td>
    </tr>
  <% end %>
</table>
```

Теперь, если перейти в `http://localhost:3000/posts`, можно увидеть список всех публикаций, которые вы уже создали.

### Добавление ссылки

Теперь вы можете создавать и просматривать отдельную и все публикации. Давайте добавим несколько ссылок для навигации между страницами.

Откройте `app/views/welcome/index.html.erb` и измените его следующим образом:

```html+erb
<h1>Hello, Rails!</h1>
<%= link_to "My Blog", controller: "posts" %>
```

Метод `link_to` - один из встроенных хелперов Rails. Он создает гиперссылку, на основе текста для отображения и указания куда перейти - в нашем случае путь для контроллера posts.

Давайте добавим ссылки и в другие вьюхи, начнем с добавления ссылки "New Post" в `app/views/posts/index.html.erb`, поместив ее над тегом `<table>`:

```erb
<%= link_to 'New post', new_post_path %>
```

Эта ссылка позволит перейти на форму для создания новой публикации. Также следует добавить ссылку в этот шаблон - `app/views/posts/new.html.erb` - чтобы вернуться обратно в экшн `index`. Добавьте ее под формой в этом шаблоне:

```html+erb
<%= form_for :post do |f| %>
  ...
<% end %>

<%= link_to 'Back', posts_path %>
```

Наконец, добавьте также ссылку в шаблон `app/views/posts/show.html.erb`, чтобы также вернуться в экшн `index`, чтобы просматривающие отдельную публикацию могли вернуться и просмотреть снова полный список:

```html+erb
<p>
  <strong>Title:</strong>
  <%= @post.title %>
</p>

<p>
  <strong>Text:</strong>
  <%= @post.text %>
</p>

<%= link_to 'Back', posts_path %>
```

TIP: Если вам нужна ссылка на экшн того же контроллера, не нужно определять опцию `:controller`, так как Rails по умолчанию использует текущий контроллер.

TIP: В режиме development (с которым вы работаете по умолчанию), Rails перегружает ваше приложение с каждым запросом браузера, так что не нужно останавливать и перезапускать веб-сервер при внесении изменений.

### Обновление полей

Файл модели `app/models/post.rb` выглядит проще простого:

```ruby
class Post < ActiveRecord::Base
end
```

Не так уж много написано в этом файле, но заметьте, что класс `Post` наследован от `ActiveRecord::Base`. Active Record обеспечивает огромную функциональность для Ваших моделей Rails, включая основные операции для базы данных CRUD (Create, Read, Update, Destroy - создать, читать, обновить, уничтожить), валидации данных, сложную поддержку поиска и возможность устанавливать отношения между разными моделями.

### Добавим некоторую валидацию

Rails включает методы, помогающие проверить данные, которые вы передаете в модель. Откройте файл `app/models/post.rb` и отредактируйте:

```ruby
class Post < ActiveRecord::Base
  validates :title, presence: true,
                    length: { minimum: 5 }
end
```

Эти изменения позволят быть уверенным, что все публикации имеют заголовок длиной как минимум пять символов. Rails может проверять разные условия в модели, включая существование или уникальность полей, их формат и существование связанных объектов. Подробнее валидации раскрыты в [Валидации Active Record](/active-record-validations)

Теперь, когда есть валидации, при вызове `@post.save` на невалидной публикации, будет возвращен `false`. Если снова открыть `app/controllers/posts_controller.rb`, вы увидите, что мы не проверяем результат вызова `@post.save` в экшне `create`. Если в этой ситуации `@post.save` не удастся, нам нужно снова показать форму пользователю. Для этого замените экшны `new` и `create` в `app/controllers/posts_controller.rb` на эти:

```ruby
def new
  @post = Post.new
end

def create
  @post = Post.new(params[:post].permit(:title, :text))

  if @post.save
    redirect_to @post
  else
    render 'new'
  end
end
```

Теперь экшн `new` создает новую переменную экземпляра по имени `@post`, и вы увидите, зачем это, через пару абзацев.

Отметьте, что в экшне `create` мы использовали `render` вместо `redirect_to`, когда `save` возвращает `false`. Метод `render` использован, чтобы объект `@post` был передан назад в шаблон `new`, когда он будет отрендерен. Этот рендеринг выполняется в рамках того же запроса, что и отправка формы, в то время как `redirect_to` сообщает браузеру выполнить другой запрос.

Если перезагрузите <http://localhost:3000/posts/new> и попытаетесь сохранить публикацию без заголовка, Rails вернет вас обратно на форму, но это не очень полезно. Вам нужно сказать пользователю, что что-то пошло не так. Для этого нужно модифицировать `app/views/posts/new.html.erb` для проверки на сообщения об ошибке:

```html+erb
<%= form_for :post, url: posts_path do |f| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited
        this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>
  <p>
    <%= f.label :title %><br>
    <%= f.text_field :title %>
  </p>

  <p>
    <%= f.label :text %><br>
    <%= f.text_area :text %>
  </p>

  <p>
    <%= f.submit %>
  </p>
<% end %>

<%= link_to 'Back', posts_path %>
```

Несколько вещей о том, что происходит. Мы проверяем, имеются ли какие-либо ошибки с помощью `@post.errors.any?`, и в этом случае показываем список всех ошибок с помощью `@post.errors.full_messages`.

`pluralize` это хелпер rails, принимающий число и строку как аргументы. Если число больше одного, строка будет автоматически склонено во множественном числе.

Причина, по которой мы добавили `@post = Post.new` в `posts_controller`, в том, что в противном случае `@post` будет `nil` во вьюхе, и вызов `@post.errors.any?` вызовет ошибку.

TIP: Rails автоматически оборачивает поля, содержащие ошибку, в div с классом `field_with_errors`. Можно определить правило css, чтобы сделать их выделяющимися.

Теперь у нас будет прекрасное сообщение об ошибке при сохранении публикации без заголовка, если попробуете так сделать в форме новой публикации [(http://localhost:3000/posts/new)](http://localhost:3000/posts/new).

![Форма с ошибками](/assets/guides/getting_started/form_with_errors.png)

### Обновление публикаций

Мы раскрыли часть "CR" от CRUD. Теперь сфокусируемся на части "U", обновлении (updating) публикаций.

Первым шагом следует добавить экшн `edit` в `posts_controller`.

```ruby
def edit
  @post = Post.find(params[:id])
end
```

Вьюха будет содержать форму, схожую с той, которую мы использовали при создании новых публикаций. Создайте файл с именем `app/views/posts/edit.html.erb` и добавьте в него следующее:

```html+erb
<h1>Editing post</h1>

<%= form_for :post, url: post_path(@post.id) },
method: :patch do |f| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited
        this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>
  <p>
    <%= f.label :title %><br>
    <%= f.text_field :title %>
  </p>

  <p>
    <%= f.label :text %><br>
    <%= f.text_area :text %>
  </p>

  <p>
    <%= f.submit %>
  </p>
<% end %>

<%= link_to 'Back', posts_path %>
```

Сейчас мы указываем форме на экшн `update`, который пока не определен, но скоро мы это сделаем.

Опция `method: :patch` говорит Rails, что мы хотим, чтобы эта форма была отправлена с помощью `PATCH`, метода HTTP, от которого ожидается, что он используется для **обновления** ресурсов в соответствии с протоколом REST.

TIP: По умолчанию, формы, созданные с помощью хелпера _form_for_, отсылаются через `POST`.

Затем нужно создать экшн `update` в `app/controllers/posts_controller.rb`:

```ruby
def update
  @post = Post.find(params[:id])

  if @post.update(params[:post].permit(:title, :text))
    redirect_to @post
  else
    render 'edit'
  end
end
```

Новый метод, `update`, используется, когда хотите обновить запись, которая уже существует, и он принимает хэш, содержащий атрибуты, которые вы хотите обновить. Как и прежде, если будет ошибка обновления публикации, мы хотим опять показать форму пользователю.

TIP: Вам не нужно передавать все атрибуты в `update`. к примеру, если вызовите `@post.update(title: 'A new title')` Rails обновит только атрибут `title`, оставив все другие атрибуты нетронутыми.

Наконец, мы хотим показать ссылку на экшн `edit` в списке всех публикаций, так что, давайте добавим ее в `app/views/posts/index.html.erb` рядом с ссылкой "Show":

```html+erb
<table>
  <tr>
    <th>Title</th>
    <th>Text</th>
    <th></th>
    <th></th>
  </tr>

<% @posts.each do |post| %>
  <tr>
    <td><%= post.title %></td>
    <td><%= post.text %></td>
    <td><%= link_to 'Show', post_path %></td>
    <td><%= link_to 'Edit', edit_post_path(post) %></td>
  </tr>
<% end %>
</table>
```

И также добавим в шаблон `app/views/posts/show.html.erb`, чтобы ссылка "Edit" также была на странице публикации. Добавьте следующее в конце шаблона:

```html+erb
...

<%= link_to 'Back', posts_path %>
| <%= link_to 'Edit', edit_post_path(@post) %>
```

И вот как выглядит наше приложение сейчас:

![Экшн index с ссылкой на редактирование](/assets/guides/getting_started/index_action_with_edit_link.png)

### Использование партиалов для очистки повторения во вьюхах

Наша страница `edit` очень похожа на страницу `new`, фактически они используют один и тот же код для отображения формы. Давайте уберем некоторое дублирование, использовав партиал вьюхи. По соглашению, файлы партиалов начинаются со знака подчеркивания.

TIP: Подробнее о партиалах можно прочитать в руководстве [Макеты и рендеринг в Rails](/layouts-and-rendering-in-rails).

Создайте новый файл `app/views/posts/_form.html.erb` со следующим содержимым:

```html+erb
<%= form_for @post do |f| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited
      this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>
  <p>
    <%= f.label :title %><br>
    <%= f.text_field :title %>
  </p>

  <p>
    <%= f.label :text %><br>
    <%= f.text_area :text %>
  </p>

  <p>
    <%= f.submit %>
  </p>
<% end %>
```

Все, за исключением объявления `form_for`, осталось тем же самым. Как `form_for` может определить правильные атрибуты `action` и `method` при создании формы будет объяснено немного позже. А сейчас давайте обновим вьюху `app/views/posts/new.html.erb`, чтобы использовать этот новый партиал, переписав ее полностью:

```html+erb
<h1>New post</h1>

<%= render 'form' %>

<%= link_to 'Back', posts_path %>
```

И то же самое для вьюхи `app/views/posts/edit.html.erb`:

```html+erb
<h1>Edit post</h1>

<%= render 'form' %>

<%= link_to 'Back', posts_path %>
```

### Удаление публикаций

Теперь мы готовы раскрыть часть "D" от CRUD, удаление (deleting) из базы данных. Следуя соглашению REST, маршрут для удаления публикаций в `config/routes.rb` следующий:

```ruby
DELETE /posts/:id(.:format)      posts#destroy
```

Метод роутинга `delete` должен быть использован для маршрутов, уничтожающих ресурсы. Если бы его оставить обычным маршрутом `get`, станет возможным создавать следующие злонамеренные URL:

```html
<a href='http://example.com/posts/1/destroy'>look at this cat!</a>
```

Мы используем метод `delete` для уничтожения ресурсов, и этот маршрут связывается с экшном `destroy` в `app/controllers/posts_controller.rb`, который еще не существует, но представлен ниже:

```ruby
def destroy
  @post = Post.find(params[:id])
  @post.destroy

  redirect_to posts_path
end
```

Можно вызывать `destroy` на объектах Active Record, когда вы хотите удалить их из базы данных. Отметьте, что нам не нужно добавлять вьюху для этого экшна, так как мы перенаправляем на экшн `index`.

Наконец, дабавим ссылку 'destroy' в шаблон экшна `index` (`app/views/posts/index.html.erb`), собрав все ссылки вместе.

```html+erb
<h1>Listing Posts</h1>
<table>
  <tr>
    <th>Title</th>
    <th>Text</th>
    <th></th>
    <th></th>
    <th></th>
  </tr>

<% @posts.each do |post| %>
  <tr>
    <td><%= post.title %></td>
    <td><%= post.text %></td>
    <td><%= link_to 'Show', post_path %></td>
    <td><%= link_to 'Edit', edit_post_path(post) %></td>
    <td><%= link_to 'Destroy', post_path(post),
                    method: :delete, data: { confirm: 'Are you sure?' } %></td>
  </tr>
<% end %>
</table>
```

Тут мы используем `link_to` другим образом. Мы передаем именнованный маршрут как первый аргумент, а последние два ключа как другой аргумент. Опции `:method` и `:data-confirm` используются как атрибуты html5, поэтому при нажатии ссылки, Rails сначала покажет пользователю диалог подтверждения, а затем отправит ссылку с помощью метода `delete`. Это выполняется с помощью файла JavaScript `jquery_ujs`, который автоматически включается в макет пиложения (`app/views/layouts/application.html.erb`) при создании приложени. Без этого файла диалог подтверждения не будет показан.

![Диалог подтверждения](/assets/guides/getting_started/confirm_dialog.png)

Наши поздравления, теперь вы можете создавать, просматривать все и по отделности, обновлять и уничтожать публикации.

TIP: В основном, Rails рекомендует использовать ресурсные объекты вместо объявления маршрутов вручную. Подробнее о роутинге смотрите [Роутинг в Rails](/rails-routing).

Добавляем вторую модель
-----------------------

Настало время добавить вторую модель в приложение. Вторая модель будет управлять комментариями на публикации блога.

### Генерируем модель

Мы намереваемся использовать тот же генератор, что мы использовали ранее при создании модели `Post`. В этот раз мы создадим модель `Comment`, содержащую комментарии к публикации. Запустите следующую команду в терминале:

```bash
$ rails generate model Comment commenter:string body:text post:references
```

Эта команда создаст четыре файла:

| Файл                                        | Назначение |
|---------------------------------------------|------------|
|db/migrate/20100207235629_create_comments.rb | Миграция для создания таблицы comments в вашей базе данных (ваше имя файла будет включать другую временную метку) |
| app/models/comment.rb                       | Модель Comment |
| test/models/comment_test.rb                 | Каркас для тестирования модели комментариев |
| test/fixtures/comments.yml                  | Образцы комментариев для использования в тестировании |

Сначала взглянем на `app/models/comment.rb`:

```ruby
class Comment < ActiveRecord::Base
  belongs_to :post
end
```

Это очень похоже на модель `post.rb`, которую мы видели ранее. Разница в строке `belongs_to :post`, которая устанавливает _связь_ Active Record. Вы ознакомитесь со связями в следующем разделе руководства.

В дополнение к модели, Rails также сделал миграцию для создания соответствующей таблицы базы данных:

```ruby
class CreateComments < ActiveRecord::Migration
  def change
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :post

      t.timestamps
    end

    add_index :comments, :post_id
  end
end
```

Строка `t.references` устанавливает столбец внешнего ключа для связи между двумя моделями. А строка `add_index` настраивает индексирование для этого столбца связи. Далее запускаем миграцию:

```bash
$ rake db:migrate
```

Rails достаточно сообразителен, чтобы запускать только те миграции, которые еще не были запущены для текущей базы данных, в нашем случае Вы увидите:

```bash
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -> 0.0008s
-- add_index(:comments, :post_id)
   -> 0.0003s
==  CreateComments: migrated (0.0012s) ========================================
```

### Связываем модели

Связи Active Record позволяют Вам легко объявлять отношения между двумя моделями. В случае с комментариями и публикациями, Вы можете описать отношения следующим образом:

* Каждый комментарий принадлежит одной публикации.
* Одна публикация может иметь много комментариев.

Фактически, это очень близко к синтаксису, который использует Rails для объявления этой связи. Вы уже видели строку кода в модели `Comment` (app/models/comment.rb), которая делает каждый комментарий принадлежащим публикации:

```ruby
class Comment < ActiveRecord::Base
  belongs_to :post
end
```

Вам нужно отредактировать `app/models/post.rb`, добавив другую сторону связи:

```ruby
class Post < ActiveRecord::Base
  has_many :comments
  validates :title, presence: true,
                    length: { minimum: 5 }
  [...]
end
```

Эти два объявления автоматически делают доступным большое количество возможностей. Например, если у вас есть переменная экземпляра `@post`, содержащая публикацию, вы можете получить все комментарии, принадлежащие этой публикации, в массиве, вызвав `@post.comments`.

TIP: Более подробно о связях Active Record смотрите руководство [Связи Active Record](/active-record-associations).

### Добавляем маршрут для комментариев

Как в случае с контроллером `welcome`, нам нужно добавить маршрут, чтобы Rails знал, по какому адресу мы хотим пройти, чтобы увидеть `комментарии`. Снова откройте файл `config/routes.rb` и отредактируйте его следующим образом:

```ruby
resources :posts do
  resources :comments
end
```

Это создаст `comments` как _вложенный ресурс_ в `posts`. Это другая сторона захвата иерархических отношений, существующих между публикациями и комментариями.

TIP: Более подробно о роутинге написано в руководстве [Роутинг в Rails](/rails-routing).

### Генерируем контроллер

Имея модель, обратим свое внимание на создание соответствующего контроллера. Снова будем использовать то же генератор, что использовали прежде:

```bash
$ rails generate controller Comments
```

Создадутся шесть файлов и пустая директория:

| Файл/Директория                              | Назначение                                |
|--------------------------------------------- |-------------------------------------------|
| app/controllers/comments_controller.rb       | Контроллер Comments                       |
| app/views/comments/                          | Вьюхи контроллера хранятся здесь          |
| test/controllers/comments_controller_test.rb | Тест для контроллера                      |
| app/helpers/comments_helper.rb               | Хелпер для вьюх                           |
| test/unit/helpers/comments_helper_test.rb    | Юнит-тесты для хелпера                    |
| app/assets/javascripts/comment.js.coffee     | CoffeeScript для контроллера              |
| app/assets/stylesheets/comment.css.scss      | Каскадная таблица стилей для контроллера  |

Как и в любом другом блоге, наши читатели будут создавать свои комментарии сразу после прочтения публикации, и после добавления комментария они будут направляться обратно на страницу отображения публикации и видеть, что их комментарий уже отражен. В связи с этим, наш `CommentsController` служит как средство создания комментариев и удаления спама, если будет.

Сначала мы расширим шаблон Post show (`app/views/posts/show.html.erb`), чтобы он позволял добавить новый комментарий:

```html+erb
<p>
  <strong>Title:</strong>
  <%= @post.title %>
</p>

<p>
  <strong>Text:</strong>
  <%= @post.text %>
</p>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <p>
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit %>
  </p>
<% end %>

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %>
```

Это добавит форму на страницу отображения публикации, создающую новый комментарий при вызове экшна `create` в `CommentsController`. Тут вызов `form_for` использует массив, что создаст вложенный маршрут, такой как `/posts/1/comments`.

Давайте напишем `create` в `app/controllers/comments_controller.rb`:

```ruby
class CommentsController < ApplicationController
  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment].permit(:commenter, :body))
    redirect_to post_path(@post)
  end
end
```

Тут все немного сложнее, чем вы видели в контроллере для публикаций. Это побочный эффект вложения, которое вы настроили. Каждый запрос к комментарию отслеживает публикацию, к которой комментарий присоединен, таким образом сначала решаем вопрос с получением публикации, вызвав `find` на модели `Post`.

Кроме того, код пользуется преимуществом некоторых методов, доступных для связей. Мы используем метод `create` на `@post.comments`, чтобы создать и сохранить комментарий. Это автоматически связывает комментарий так, что он принадлежит к определенной публикации.

Как только мы создали новый комментарий, мы возвращаем пользователя обратно на оригинальную публикацию, используя хелпер `post_path(@post)`. Как мы уже видели, он вызывает экшн `show` в `PostsController`, который, в свою очередь, рендерит шаблон `show.html.erb`. В этом месте мы хотим отображать комментарии, поэтому давайте добавим следующее в `app/views/posts/show.html.erb`.

```html+erb
<p>
  <strong>Title:</strong>
  <%= @post.title %>
</p>

<p>
  <strong>Text:</strong>
  <%= @post.text %>
</p>

<h2>Comments</h2>
<% @post.comments.each do |comment| %>
  <p>
    <strong>Commenter:</strong>
    <%= comment.commenter %>
  </p>

  <p>
    <strong>Comment:</strong>
    <%= comment.body %>
  </p>
<% end %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <p>
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit %>
  </p>
<% end %>

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %>
```

Теперь в вашем блоге можно добавлять публикации и комментарии и отображать их в нужных местах.

![Публикация с комментариями](/assets/guides/getting_started/post_with_comments.png)

Рефакторинг
-----------

Теперь, когда у нас есть работающие публикации и комментарии, взглянем на шаблон `app/views/posts/show.html.erb`. Он стал длинным и неудобным. Давайте воспользуемся партиалами, чтобы разгрузить его.

### Рендеринг коллекций партиалов

Сначала сделаем партиал для комментариев, показывающий все комментарии для публикации. Создайте файл `app/views/comments/_comment.html.erb` и поместите в него следующее:

```html+erb
<p>
  <strong>Commenter:</strong>
  <%= comment.commenter %>
</p>

<p>
  <strong>Comment:</strong>
  <%= comment.body %>
</p>
```

Затем можно изменить `app/views/posts/show.html.erb` вот так:

```html+erb
<p>
  <strong>Title:</strong>
  <%= @post.title %>
</p>

<p>
  <strong>Text:</strong>
  <%= @post.text %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <p>
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit %>
  </p>
<% end %>

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %>
```

Теперь это отрендерит партиал `app/views/comments/_comment.html.erb` по разу для каждого комментария в коллекции `@post.comments`. Так как метод `render` перебирает коллекцию `@post.comments`, он назначает каждый комментарий локальной переменной с именем, как у партиала, в нашем случае `comment`, которая нам доступна в партиале для отображения.

### Рендеринг партиальной формы

Давайте также переместим раздел нового коментария в свой партиал. Опять же, создайте файл `app/views/comments/_form.html.erb`, содержащий:

```html+erb
<%= form_for([@post, @post.comments.build]) do |f| %>
  <p>
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </p>
  <p>
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </p>
  <p>
    <%= f.submit %>
  </p>
<% end %>
```

Затем измените `app/views/posts/show.html.erb` следующим образом:

```html+erb
<p>
  <strong>Title:</strong>
  <%= @post.title %>
</p>

<p>
  <strong>Text:</strong>
  <%= @post.text %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %>
```

Второй render всего лишь определяет шаблон партиала, который мы хотим рендерить, `comments/form`. Rails достаточно сообразительный, чтобы подставить подчеркивание в эту строку и понять, что Вы хотели рендерить файл `_form.html.erb` в директории `app/views/comments`.

Объект `@post` доступен в любых партиалах, рендерируемых во вьюхе, так как мы определили его как переменную экземпляра.

Удаление комментариев
---------------------

Другой важной особенностью блога является возможность удаления спама. Чтобы сделать это, нужно вставить некоторую ссылку во вьюхе и экшн `DELETE` в `CommentsController`.

Поэтому сначала добавим ссылку для удаления в партиал `app/views/comments/_comment.html.erb`:

```html+erb
<p>
  <strong>Commenter:</strong>
  <%= comment.commenter %>
</p>

<p>
  <strong>Comment:</strong>
  <%= comment.body %>
</p>

<p>
  <%= link_to 'Destroy Comment', [comment.post, comment],
               method: :delete,
               data: { confirm: 'Are you sure?' } %>
</p>
```

Нажатие этой новой ссылки "Destroy Comment" запустит `DELETE /posts/:post_id/comments/:id` в нашем `CommentsController`, который затем будет использоваться для нахождения комментария, который мы хотим удалить, поэтому давайте добавим экшн destroy в наш контроллер (`app/controllers/comments_controller.rb`):

```ruby
class CommentsController < ApplicationController

  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end

  def destroy
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
    @comment.destroy
    redirect_to post_path(@post)
  end

end
```

Экшн `destroy` найдет публикацию, которую мы просматриваем, обнаружит комментарий в коллекции `@post.comments` и затем уберет его из базы данных и вернет нас обратно на просмотр публикации.

### Удаление связанных объектов

Если удаляете публикацию, связанные с ней комментарии также должны быть удалены. В ином случае они будут просто занимать место в базе данных. Rails позволяет использовать опцию `dependent` на связи для достижения этого. Измените модель Post, `app/models/post.rb`, следующим образом:

```ruby
class Post < ActiveRecord::Base
  has_many :comments, dependent: :destroy
  validates :title, presence: true,
                    length: { minimum: 5 }
  [...]
end
```

Безопасность
------------

Если вы опубликуете свой блог онлайн, любой сможет добавлять, редактировать и удалять публикации или удалять комментарии.

Rails предоставляет очень простую аутентификационную систему HTTP, которая хорошо работает в этой ситуации.

В `PostsController` нам нужен способ блокировать доступ к различным экшнам, если пользователь не аутентифицирован, тут мы можем использовать метод Rails `http_basic_authenticate_with`, разрешающий доступ к требуемым экшнам, если метод позволит это.

Чтобы использовать систему аутентификации, мы определим ее вверху нашего `PostsController`, в нашем случае, мы хотим, чтобы пользователь был аутентифицирован для каждого экшна, кроме `index` и `show`, поэтому напишем так в `app/controllers/posts_controller.rb`:

```ruby
class PostsController < ApplicationController

  http_basic_authenticate_with name: "dhh", password: "secret", except: [:index, :show]

  def index
    @posts = Post.all
  end

  # пропущено для краткости
```

Мы также хотим позволить только аутентифицированным пользователям удалять комментарии, поэтому в `CommentsController` (`app/controllers/comments_controller.rb`) мы напишем:

```ruby
class CommentsController < ApplicationController

  http_basic_authenticate_with name: "dhh", password: "secret", only: :destroy

  def create
    @post = Post.find(params[:post_id])
  end

  # пропущено для краткости
```

Теперь, если попытаетесь создать новую публикацию, то встретитесь с простым вызовом аутентификации HTTP

![Простой вызов аутентификации HTTP](/assets/guides/getting_started/challenge.png)

Что дальше?
-----------

После того, как вы создали свое первое приложение на Rails, можете свободно его модифицировать и экспериментировать на свое усмотрение. Но без посторонней помощи, вы, скорее всего, ничего не сможете сделать. Так же, как вы обращались к этому руководству "Rails для начинающих", далее можете так же свободно пользоваться этими ресурсами:

* [Ruby on Rails guides](http://guides.rubyonrails.org/)
* [Ruby on Rails Tutorial](http://railstutorial.org/book)
* [Ruby on Rails mailing list](http://groups.google.com/group/rubyonrails-talk)
* Канал [#rubyonrails](irc://irc.freenode.net/#rubyonrails) на irc.freenode.net

Отдельно хотелось бы выделить и поддержать следующие хорошие русскоязычные ресурcы по Ruby on rails:

* [Ruby on Rails по-русски](http://rusrails.ru/)
* [Изучение Rails на примерах (Майкл Харт)](http://russian.railstutorial.org)
* [Блог 'Ruby on Rails c нуля!'](http://rubydev.ru/)
* [Railsclub - организация конференций](http://railsclub.ru)

Rails также поставляется со встроенной помощью, которую вы можете вызвать, используя коммандную утилиту rake:

* Запуск `rake doc:guides` выложит полную копию Rails Guides в папку `/doc/guides` вашего приложения. Откройте `/doc/guides/index.html` в веб-браузере, для обзора руководства.
* Запуск `rake doc:rails` выложит полную копию документацию по API для Rails в папку `/doc/api` вашего приложения. Откройте `/doc/api/index.html` в веб-браузере, для обзора документации по API.

TIP: Чтобы генерировать Rails Guides локально с помощью рейк таска `doc:guides`, вам нужно установить гем RedCloth. Добавьте его в ваш `Gemfile` и запустите каманду `bundle install`, и можно продолжать.

Ошибки конфигурации
--------------------

Простейший способ работы с Rails заключается в хранении всех внешних данных в UTF-8. Если не так, библиотеки Ruby и Rails часто будут способны конвертировать ваши родные данные в UTF-8, но это не всегда надежно работает, поэтому лучше быть уверенным, что все внешние данные являются UTF-8.

Если вы допускаете ошибку в этой области, наиболее обычным симптомом является черный ромбик со знаком вопроса внутри, появляющийся в браузере. Другим обычным симптомом являются символы, такие как "Ã¼" появляющиеся вместо "ü". Rails предпринимает ряд внутренних шагов для смягчения общих случаев тех проблем, которые могут быть автоматически обнаружены и исправлены. Однако, если имеются внешние данные, не хранящиеся в UTF-8, это может привести к такого рода проблемам, которые не могут быть автоматически обнаружены Rails и исправлены.

Два наиболее обычных источника данных, которые не в UTF-8:

* Ваш текстовый редактор: Большинство текстовых редакторов (такие как TextMate), по умолчанию сохраняют файлы как UTF-8. Если ваш текстовый редактор так не делает, это может привести к тому, что специальные символы, введенные в ваши шаблоны (такие как é) появятся как ромбик с вопросительным знаком в браузере. Это также касается ваших файлов перевода i18N. Большинство редакторов, не устанавливающие по умолчанию UTF-8 (такие как некоторые версии Dreamweaver) предлагают способ изменить умолчания на UTF-8. Сделайте так.
* Ваша база данных. Rails по умолчанию преобразует данные из вашей базы данных в UTF-8 на границе. Однако, если ваша база данных не использует внутри UTF-8, она может не быть способной хранить все символы, которые введет ваш пользователь. Например, если ваша база данных внутри использует Latin-1, и ваш пользователь вводит русские, ивритские или японские символы, данные будут потеряны как только попадут в базу данных. Если возможно, используйте UTF-8 как внутреннее хранилище в своей базе данных.
