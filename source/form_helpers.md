Хелперы форм в Action View
==========================

Формы в веб-приложениях - это основной интерфейс для пользовательского ввода. Однако, разметка форм может быстро стать нудной в написании и поддержке из-за необходимости обрабатывать имена элементов управления формы и их бесчисленные атрибуты. Rails устраняет эту сложность, предоставляя хелперы вьюх для генерации разметки форм. Однако, поскольку эти хелперы имеют разные принципы использования, разработчикам нужно знать различия между похожими методами хелперов, прежде чем начать их использовать.

После прочтения этого руководства, вы узнаете:

* Как создавать формы поиска и подобного рода формы, не представляющие определенную модель вашего приложения
* Как сделать модельно-ориентированные формы для создания и редактирования определенных записей базы данных
* Как сгенерировать списки выбора (select box) с различными типами данных
* Какие хелперы даты и времени предоставляет Rails
* В чем особенность формы загрузки файлов
* Как отправлять формы на внешние ресурсы и указывать настройку `authenticity_token`.
* Как создавать сложные формы

NOTE: Это руководство не является подробной документацией по доступным хелперам форм и их аргументам. Для получения полной информации, обратитесь к [документации по Rails API](http://api.rubyonrails.org/).

Разбираемся с простыми формами
------------------------------

Главный хелпер форм - это `form_with`.

```erb
<%= form_with do %>
  Содержимое формы
<% end %>
```

При подобном вызове без аргументов, он создает тег формы, который при отправке сформирует POST-запрос на текущую страницу. Например, предположим текущая страница является домашней, тогда сгенерированный HTML будет выглядеть следующим образом (некоторые разрывы строчек добавлены для читаемости):

```html
<form accept-charset="UTF-8" action="/" data-remote="true" method="post">
  <input name="authenticity_token" type="hidden" value="J7CBxfHalt49OSHp27hblqK20c9PgwJ108nDHX/8Cts=" />
  Содержимое формы
</form>
```

Можно увидеть, что HTML содержит элемент `input` с типом `hidden`. Этот `input` важен, поскольку без него форма, у которой action не "GET", не может быть успешно отправлена. Скрытый элемент input с именем `authenticity_token` является особенностью безопасности Rails, называемой **защитой от межсайтовой подделки запроса**, и хелперы форм генерируют его для каждой формы, у которых action не "GET" (при условии, что эта особенность безопасности включена). Подробнее об этом можно прочитать в руководстве [Безопасность приложений на Rails](/ruby-on-rails-security-guide#cross-site-request-forgery-csrf).

### Характерная форма поиска

Одной из наиболее простых форм, встречающихся в вебе, является форма поиска. Эта форма содержит:

* элемент формы с методом "GET",
* метку для поля ввода,
* элемент поля ввода текста и
* элемент отправки.

Чтобы создать эту форму, используем, соответственно, `form_with`, `label_tag`, `text_field_tag` и `submit_tag`. Как здесь:

```erb
<%= form_with(url: "/search", method: "get") do %>
  <%= label_tag(:q, "Search for:") %>
  <%= text_field_tag(:q) %>
  <%= submit_tag("Search") %>
<% end %>
```

Это сгенерирует следующий HTML:

```html
<form accept-charset="UTF-8" action="/search" data-remote="true" method="get">
  <label for="q">Search for:</label>
  <input id="q" name="q" type="text" />
  <input name="commit" type="submit" value="Search" data-disable-with="Search" />
</form>
```

TIP: Передача `url: my_specified_path` в `form_with` сообщает форме, куда осуществлять запрос. Однако, как объясняется ниже, в форму также можно передавать объекты ActiveRecord.

TIP: Для каждого поля ввода формы генерируется атрибут ID из его имени (`"q"` в примере). Эти ID могут быть очень полезны для стилизации CSS или управления элементами форм с помощью JavaScript.

IMPORTANT: Используйте "GET" как метод для форм поиска. Это позволяет пользователям добавлять в закладки определенный поиск и потом возвращаться к нему. В более общем смысле Rails призывает вас использовать правильный метод HTTP для экшна.

### Хелперы для генерации элементов формы

Rails предоставляет ряд хелперов для генерации элементов формы, таких как чекбоксы, текстовые поля, радиокнопки и так далее. Эти простые хелперы с именами, оканчивающимися на `_tag` (такие как `text_field_tag` и `check_box_tag`), генерируют только один элемент `<input>`. Первый параметр у них это всегда имя поля ввода. Когда форма будет отправлена, имя будет передано вместе с данными формы, и, в свою очередь, помещено в `params` в контроллере со значением, введенным пользователем для этого поля. Например, если форма содержит `<%= text_field_tag(:query) %>`, то значение этого поля можно получить в контроллере с помощью `params[:query]`.

При именовании полей ввода Rails использует определенные соглашения, делающие возможным отправлять параметры с нескалярными величинами, такими как массивы и хэши, которые также будут доступны в `params`. Подробнее об этом можно прочесть в разделе [разделе про именование параметров](#understanding-parameter-naming-conventions). Для подробностей по точному использованию этих хелперов, обратитесь к [документации по API](http://api.rubyonrails.org/classes/ActionView/Helpers/FormTagHelper.html).

#### Чекбоксы

Чекбоксы - это элементы управления формой, которые дают пользователю ряд опций, которые он может включить или выключить:

```erb
<%= check_box_tag(:pet_dog) %>
<%= label_tag(:pet_dog, "I own a dog") %>
<%= check_box_tag(:pet_cat) %>
<%= label_tag(:pet_cat, "I own a cat") %>
```

Это сгенерирует следующее:

```html
<input id="pet_dog" name="pet_dog" type="checkbox" value="1" />
<label for="pet_dog">I own a dog</label>
<input id="pet_cat" name="pet_cat" type="checkbox" value="1" />
<label for="pet_cat">I own a cat</label>
```

Первый параметр у `check_box_tag` - это, разумеется, имя поля ввода. Второй параметр - это, естественно, значение поля ввода. Это значение будет включено в данные формы (и будет присутствовать в `params`), когда чекбокс нажат.

#### Радиокнопки

Радиокнопки, чем-то похожие на чекбоксы, являются элементами управления, которые определяют набор взаимоисключающих опций (т.е. пользователь может выбрать только одну):

```erb
<%= radio_button_tag(:age, "child") %>
<%= label_tag(:age_child, "I am younger than 21") %>
<%= radio_button_tag(:age, "adult") %>
<%= label_tag(:age_adult, "I am over 21") %>
```

Результат:

```html
<input id="age_child" name="age" type="radio" value="child" />
<label for="age_child">I am younger than 21</label>
<input id="age_adult" name="age" type="radio" value="adult" />
<label for="age_adult">I am over 21</label>
```

Как и у `check_box_tag`, второй параметр для `radio_button_tag` - это значение поля ввода. Так как эти две радиокнопки имеют одинаковое имя (`age`), пользователь может выбрать одну, и `params[:age]` будет содержать или `"child"`, или `"adult"`.

NOTE: Всегда используйте метки (labels) для чекбоксов и радиокнопок. Они связывают текст с определенной опцией и, предоставляя большее пространство для клика, упрощают выбор пользователем нужного пункта радиокнопки.

### Другие интересные хелперы

Среди других элементов управления формой стоит упомянуть текстовые области и следующие поля: паролей, скрытые, поиска, ввода телефона, даты, времени, цвета, локальных даты-времени, месяца, недели, url, email, числовые и интервалов:

```erb
<%= text_area_tag(:message, "Hi, nice site", size: "24x6") %>
<%= password_field_tag(:password) %>
<%= hidden_field_tag(:parent_id, "5") %>
<%= search_field(:user, :name) %>
<%= telephone_field(:user, :phone) %>
<%= date_field(:user, :born_on) %>
<%= datetime_local_field(:user, :graduation_day) %>
<%= month_field(:user, :birthday_month) %>
<%= week_field(:user, :birthday_week) %>
<%= url_field(:user, :homepage) %>
<%= email_field(:user, :address) %>
<%= color_field(:user, :favorite_color) %>
<%= time_field(:task, :started_at) %>
<%= number_field(:product, :price, in: 1.0..20.0, step: 0.5) %>
<%= range_field(:product, :discount, in: 1..100) %>
```

Результат:

```html
<textarea id="message" name="message" cols="24" rows="6">Hi, nice site</textarea>
<input id="password" name="password" type="password" />
<input id="parent_id" name="parent_id" type="hidden" value="5" />
<input id="user_name" name="user[name]" type="search" />
<input id="user_phone" name="user[phone]" type="tel" />
<input id="user_born_on" name="user[born_on]" type="date" />
<input id="user_graduation_day" name="user[graduation_day]" type="datetime-local" />
<input id="user_birthday_month" name="user[birthday_month]" type="month" />
<input id="user_birthday_week" name="user[birthday_week]" type="week" />
<input id="user_homepage" name="user[homepage]" type="url" />
<input id="user_address" name="user[address]" type="email" />
<input id="user_favorite_color" name="user[favorite_color]" type="color" value="#000000" />
<input id="task_started_at" name="task[started_at]" type="time" />
<input id="product_price" max="20.0" min="1.0" name="product[price]" step="0.5" type="number" />
<input id="product_discount" max="100" min="1" name="product[discount]" type="range" />
```

Скрытые поля не отображаются пользователю, вместо этого они содержат данные, как и любое текстовое поле. Их значения могут быть изменены с помощью JavaScript.

IMPORTANT: Поля поиска, ввода телефона, даты, времени, цвета, даты-времени, локальных даты-времени, месяца, недели, url, email, числовые и интервалов - это элементы управления HTML5. Если необходимо, чтобы у вашего приложения была совместимость со старыми браузерами, вам необходим HTML5 polyfill (предоставляемый с помощью CSS и/или JavaScript). Хотя в таких решениях [нет недостатка](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills), популярным инструментом на сегодняшний момент является [Modernizr](http://www.modernizr.com/), предоставляющий простой способ добавить функциональность, основанной на обнаружении установленных особенностей HTML5.

TIP: Если используются поля для ввода пароля (для любых целей), вы можете настроить свое приложение для предотвращения появления их значений в логах приложения. Это можно изучить в руководстве [Безопасность приложений на Rails](/ruby-on-rails-security-guide).

Работаем с объектами модели
---------------------------

### Хелперы объекта модели

Наиболее частыми задачами для форм являются редактирование или создание объекта модели. В то время как хелперы `*_tag`, конечно, могут быть использованы для этой задачи, они несколько многословны, так как для каждого тега вам придется обеспечить использование правильного имени параметра и установку подходящего значения поля ввода по умолчанию. Rails предоставляет хелперы, адаптированные под эту задачу. У этих хелперов отсутствует суффикс `_tag`, например, `text_field`, `text_area`.

Для этих хелперов первый аргумент - это имя переменной экземпляра, а второй - это имя метода (обычно атрибутного), вызываемого на этом объекта. Rails установит значение value элемента управления input равным возвращаемому значению этого метода для объекта и установит подходящее имя поля ввода. Если ваш контроллер определил `@person` и имя этой персоны Henry, тогда форма, содержащая:

```erb
<%= text_field(:person, :name) %>
```

выдаст подобный результат

```erb
<input id="person_name" name="person[name]" type="text" value="Henry" />
```

После подтверждения формы, значение, введенное пользователем, будет храниться в `params[:person][:name]`.

WARNING: Необходимо передавать имя переменной экземпляра, т.е. `:person` или `"person"`, а не фактический экземпляр объекта вашей модели.

Rails предоставляет хелперы для отображения ошибок валидации, связанных с объектом модели. Детально они раскрываются в руководстве [Отображение ошибок валидации во вьюхах](/active-record-validations#displaying-validation-errors-in-the-view).

### Привязывание формы к объекту

Хотя комфортность несколько улучшилась, она еще далека от совершенства. Если у `Person` много атрибутов для редактирования, тогда мы должны повторить имя редактируемого объекта много раз. То, что мы хотим сделать, - это как-то привязать форму к объекту модели, что как раз осуществляется с помощью `form_with` с параметром `:model`.

Допустим у нас есть контроллер для работы со статьями `app/controllers/articles_controller.rb`:

```ruby
def new
  @article = Article.new
end
```

Соответствующая вьюха `app/views/articles/new.html.erb`, использующая `form_with`, выглядит так:

```erb
<%= form_with model: @article, class: "nifty_form" do |f| %>
  <%= f.text_field :title %>
  <%= f.text_area :body, size: "60x12" %>
  <%= f.submit "Create" %>
<% end %>
```

Следует отметить несколько вещей:

* `@article` - это фактический объект, который редактируется.
* Здесь есть одиночный хэш опций. Опции HTML передаются в хэше `:html`. Также для формы можно предоставить опцию `:namespace`, чтобы быть уверенным в уникальности атрибутов id элементов формы. Генерируемые для HTML id будут начинаться с префикса, заданного атрибутом пространства имен, плюс подчеркивание.
* Метод `form_with` предоставляет объект **form builder** (переменная `f`).
* Если хотите направить запрос формы на определенный url, вместо этого следует использовать `form_with url: my_nifty_url_path`. Подробнее об опциях, которые принимает `form_with`, можно узнать в [документации API](https://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-form_with).
* Методы создания элементов управления формой вызываются *для* объекта form builder `f`.

Итоговый HTML:

```html
<form class="nifty_form" action="/articles" accept-charset="UTF-8" data-remote="true" method="post">
  <input type="hidden" name="authenticity_token" value="NRkFyRWxdYNfUg7vYxLOp2SLf93lvnl+QwDWorR42Dp6yZXPhHEb6arhDOIWcqGit8jfnrPwL781/xlrzj63TA==" />
  <input type="text" name="article[title]" id="article_title" />
  <textarea name="article[body]" id="article_body" cols="60" rows="12"></textarea>
  <input type="submit" name="commit" value="Create" data-disable-with="Create" />
</form>
```

Объект, переданный как `:model` в `form_with`, контролирует ключ, используемый в `params` для доступа к значениям формы. В примере имя `article`, и поэтому все поля ввода имеют имена формы `article[attribute_name]`. Соответственно, в экшне `create` хэш `params[:article]` имеет ключи `:title` и `:body`. Подробнее о значении имен полей ввода можно прочитать в разделе [про именование параметров](#understanding-parameter-naming-conventions) этого руководства.

TIP: По соглашению, поля ввода будут отражать атрибуты модели. Однако, это необязательно! Если имеется иная необходимая информация, ее можно включить в форму, также как атрибут, и она будет доступна как `params[:article][:my_nifty_non_attribute_input]`.

Методы хелпера, вызываемые из form builder, идентичны хелперам объекта модели, за исключением того, что не нужно указывать, какой объект будет редактироваться, так как это уже регулируется в form builder.

Можно создать подобное привязывание без фактического создания тега `<form>` с помощью хелпера `fields_for`. Это полезно для редактирования дополнительных объектов модели в той же форме. Например, если имеется модель `Person` со связанной моделью `ContactDetail`, можно создать форму для создания обеих моделей подобным образом:

```erb
<%= form_with model: @person do |person_form| %>
  <%= person_form.text_field :name %>
  <%= fields_for :contact_detail, @person.contact_detail do |contact_detail_form| %>
    <%= contact_detail_form.text_field :phone_number %>
  <% end %>
<% end %>
```

которая выдаст такой результат:

```html
<form action="/people" accept-charset="UTF-8" data-remote="true" method="post">
  <input type="hidden" name="authenticity_token" value="bL13x72pldyDD8bgtkjKQakJCpd4A8JdXGbfksxBDHdf1uC0kCMqe2tvVdUYfidJt0fj3ihC4NxiVHv8GVYxJA==" />
  <input type="text" name="person[name]" id="person_name" />
  <input type="text" name="contact_detail[phone_number]" id="contact_detail_phone_number" />
</form>
```

Объект, предоставляемый `fields_for` - это form builder, подобный тому, который предоставляется `form_with`.

### Положитесь на идентификацию записи

Модель Article непосредственно доступна пользователям приложения, и таким образом, следуя лучшим рекомендациям разработки на Rails, вы должны объявить ее как **ресурс**.

```ruby
resources :articles
```

TIP: Объявление ресурса имеет несколько побочных эффектов. Смотрите руководство [Роутинг в Rails](/rails-routing) для получения более подробной информации по настройке и использованию ресурсов.

Когда работаем с ресурсами RESTful, вызовы `form_with` становятся значительно проще, если они основываются на **идентификации записи**. Вкратце, вы должны всего лишь передать экземпляр модели и позволить Rails выяснить имя модели и остальное:

```ruby
## Создание новой статьи
# длинный стиль:
form_with(model: @article, url: articles_path)
# короткий стиль:
form_with(model: @article)

## Редактирование существующей статьи
# длинный стиль:
form_with(model: @article, url: article_path(@article), method: "patch")
# короткий стиль:
form_with(model: @article)
```

Отметьте, что вызов короткого стиля `form_with` является идентичным, независимо от того, запись новая или уже существует. Идентификация записи достаточно сообразительная, чтобы выяснить, новая ли запись, запрашивая `record.new_record?`. Она также выбирает правильный путь для подтверждения и имя, основанное на классе объекта.

WARNING: Когда используется STI (наследование с единой таблицей) с вашими моделями, нельзя полагаться на идентификацию записей подкласса, если только их родительский класс определен ресурсом. Необходимо явно указывать `:url` и `:scope` (имя модели).

#### Работаем с пространствами имен

Если создать пространство имен для маршрутов, `form_with` также можно изящно сократить. Если в приложении есть пространство имен admin, то

```ruby
form_with model: [:admin, @article]
```

создаст форму, которая передается `ArticlesController` в пространстве имен admin (передача в `admin_article_path(@article)` в случае с обновлением). Если у вас несколько уровней пространства имен, тогда синтаксис подобный:

```ruby
form_with model: [:admin, :management, @article]
```

Более подробно о системе маршрутизации Rails и связанным соглашениям смотрите руководство [Роутинг в Rails](/rails-routing).

### Как формы работают с методами PATCH, PUT или DELETE?

Фреймворк Rails поддерживает стиль RESTful в ваших приложениях, что подразумевает частое использование запросов "PATCH", "PUT" и "DELETE" (помимо "GET" и "POST"). Однако, большинство браузеров _не поддерживают_ методы, отличные от "GET" и "POST", когда дело доходит до подтверждения форм.

Rails работает с этой проблемой, эмулируя другие методы с помощью POST со скрытым полем, названным `"_method"`, который установлен для отображение желаемого метода:

```ruby
form_with(url: search_path, method: "patch")
```

Результат:

```html
<form accept-charset="UTF-8" action="/search" data-remote="true" method="post">
  <input name="_method" type="hidden" value="patch" />
  <input name="authenticity_token" type="hidden" value="f755bb0ed134b76c432144748a6d4b7a7ddf2b71" />
  ...
</form>
```

При парсинге данных, отправленных с помощью POST, Rails принимает во внимание специальный параметр `_method` и ведет себя так, как будто бы в нем был определен этот метод HTTP ("PATCH" в этом примере).

IMPORTANT: Все формы с использованием `form_with` по умолчанию реализуют `remote: true`. Эти формы будут отправлять данные с помощью запроса XHR (Ajax). Чтобы это отключить, добавьте `local: true`. Подробности смотрите в руководстве [Работа с JavaScript в Rails](/working-with-javascript-in-rails#remote-elements).

Легкое создание списков выбора
------------------------------

Списки выбора в HTML требуют значительного количества разметки (один элемент `OPTION` для каждого пункта списка), поэтому целесообразнее генерировать их динамически.

Вот как может выглядеть разметка:

```html
<select name="city_id" id="city_id">
  <option value="1">Lisbon</option>
  <option value="2">Madrid</option>
  <option value="3">Berlin</option>
</select>
```

Здесь есть перечень городов, имена которых представлены пользователю. Самому приложению для обработки нужен только их ID, поэтому он используется как атрибут value пункта списка. Давайте посмотрим, как Rails может нам помочь.

### Теги Select и Option

Наиболее простой хелпер - это `select_tag`, который, как следует из имени, просто сгенерирует тег `SELECT`, инкапсулирующий строку option (пунктов списка):

```erb
<%= select_tag(:city_id, raw('<option value="1">Lisbon</option><option value="2">Madrid</option><option value="3">Berlin</option>')) %>
```

Это закладывает начало, но пока еще динамически не создает теги пунктов списка. Можно сгенерировать теги пунктов с помощью хелпера `options_for_select`:

```html+erb
<%= options_for_select([['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]]) %>
```

Результат:

```html
<option value="1">Lisbon</option>
<option value="2">Madrid</option>
<option value="3">Berlin</option>
```

Первый аргумент для `options_for_select` - это вложенный массив, в котором каждый элемент содержит два элемента: текст пункта списка (название города) и значение пункта списка (id города). Значение пункта списка - это то, что будет передано в контроллер. Часто бывает, что значение - это id соответствующего объекта базы данных, но это не всегда так.

Зная это, вы можете комбинировать `select_tag` и `options_for_select` для достижения желаемой полной разметки:

```erb
<%= select_tag(:city_id, options_for_select(...)) %>
```

`options_for_select` позволяет предварительно выбрать пункт списка, передав его значение.

```html+erb
<%= options_for_select([['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]], 2) %>
```

Результат:

```html
<option value="1">Lisbon</option>
<option value="2" selected="selected">Madrid</option>
<option value="3">Berlin</option>
```

Всякий раз, когда Rails видит, что внутреннее значение сгенерированного пункта списка соответствует этому значению, он добавит атрибут `selected` к этому пункту.

С помощью хэшей можно добавить произвольные атрибуты в option:

```html+erb
<%= options_for_select(
  [
    ['Lisbon', 1, { 'data-size' => '2.8 million' }],
    ['Madrid', 2, { 'data-size' => '3.2 million' }],
    ['Berlin', 3, { 'data-size' => '3.4 million' }]
  ], 2
) %>
```

Результат:

```html
<option value="1" data-size="2.8 million">Lisbon</option>
<option value="2" selected="selected" data-size="3.2 million">Madrid</option>
<option value="3" data-size="3.4 million">Berlin</option>
```

### Списки выбора для работы с объектами модели

В большинстве случаев элементы управления формой будут связаны с определенной моделью, и, как вы, наверное, и ожидали, Rails предоставляет хелперы, предназначенные для этой цели. Как в случае с другими хелперами форм, когда работаете с объектами модели, суффикс `_tag` отбрасывается от `select_tag`:

Если ваш контроллер определил `@person`, и city_id этого person равен 2:

```ruby
@person = Person.new(city_id: 2)
```

```erb
+<%= select(:person, :city_id, [['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]]) %>
```

Создаст результат, подобный следующему

```html
<select name="person[city_id]" id="person_city_id">
  <option value="1">Lisbon</option>
  <option value="2" selected="selected">Madrid</option>
  <option value="3">Berlin</option>
</select>
```

Отметьте, что третий параметр - массив пунктов списка - имеет тот же самый тип аргумента, что мы передавали в `options_for_select`. Одно из преимуществ заключается в том, что не стоит беспокоиться об предварительном выборе правильного города, если пользователь уже выбрал его - Rails сделает это за вас, прочитав из атрибута `@person.city_id`.

Как и в других хелперах, если хотите использовать хелпер `select` в form builder с областью видимостью объекта `@person`, синтаксис будет такой:

```erb
<%= form_with model: @person do |person_form| %>
  <%= person_form.select(:city_id, [['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]]) %>
<% end %>
```

В хелпер `select` также можно передать блок:

```erb
<%= form_with model: @person do |person_form| %>
  <%= person_form.select(:city_id) do %>
    <% [['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]].each do |c| %>
      <%= content_tag(:option, c.first, value: c.last) %>
    <% end %>
  <% end %>
<% end %>
```

WARNING: При использовании `select`, или подобных хелперов, чтобы установить связь `belongs_to`, необходимо передать имя внешнего ключа (в примере выше `city_id`), а не само имя связи.

WARNING: Когда отсутствует `:include_blank` или `:prompt`, `:include_blank` принудительно становится true, если атрибут `required` - true, отображаемый `size` - 1 и `multiple` не равен true.

### Теги пункта списка из коллекции произвольных объектов

Генерация тегов пунктов списка с помощью `options_for_select` требует, чтобы был создан массив, содержащий текст и значение для каждого пункта. Но что, если есть модель `City` (вероятно даже модель Active Record) и нужно сгенерировать теги пунктов списка из коллекции этих объектов? Одним из решений будет сделать вложенный массив с помощью итераций по ним:

```erb
<% cities_array = City.all.map { |city| [city.name, city.id] } %>
<%= options_for_select(cities_array) %>
```

Хотя это и валидное решение, но Rails предоставляет менее сложную альтернативу: `options_from_collection_for_select`. Этот хелпер принимает коллекцию произвольных объектов и два дополнительных аргумента: имена методов для считывания значений **value** и **text** пункта списка, соответственно:

```erb
<%= options_from_collection_for_select(City.all, :id, :name) %>
```

Как следует из имени хелпера, это генерирует только теги пункта списка. Для генерации работающего списка выбора, необходимо использовать `collection_select`.

```erb
<%= collection_select(:person, :city_id, City.all, :id, :name) %>
```

Как и с другими хелперами, если нужно использовать хелпер `collection_select` в связке с form builder, привязанным к объекту `@person`, синтаксис будет следующим:

```erb
<%= form_with model: @person do |person_form| %>
  <%= person_form.collection_select(:city_id, City.all, :id, :name) %>
<% end %>
```

NOTE: Пары, переданные в `options_for_select` должны сперва иметь текст, затем значение, однако для `options_from_collection_for_select` первый аргумент - это метод для значения, а второй аргумент - метод для текста.

### Выбор часового пояса и страны

Для управления поддержкой часовых поясов в Rails, можно спрашивать своих пользователей, в какой зоне они находятся. Это потребует сгенерировать пункты списка из списка предопределенных объектов [`ActiveSupport::TimeZone`](http://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html), используя `collection_select`, но можно просто использовать хелпер `time_zone_select`, который уже все это содержит:

```erb
<%= time_zone_select(:person, :time_zone) %>
```

Также есть хелпер `time_zone_options_for_select` для ручного (и поэтому гибко настраиваемого) способа осуществления этого. Читайте [документацию по API](http://api.rubyonrails.org/classes/ActionView/Helpers/FormOptionsHelper.html#method-i-time_zone_options_for_select), чтобы узнать о доступных аргументах для этих двух методов.

В Rails _раньше_ был хелпер `country_select` для выбора стран, но сейчас он вынесен во внешний [плагин country_select](https://github.com/stefanpenner/country_select).

Использование хелперов даты и времени
-------------------------------------

Можно не использовать хелперы форм, генерирующие поля ввода даты и времени HTML5, а использовать альтернативные хелперы даты и времени. Эти хелперы даты и времени отличаются от остальных хелперов форм в двух важных аспектах:

* Дата и время не представлены отдельным элементом ввода. Вместо них есть несколько, один на каждый компонент (год, месяц, день и т.д.), и поэтому нет одного значения в хэше `params` с вашими датой и временем.
* Другие хелперы используют суффикс `_tag` для обозначения, является ли хелпер скелетным, либо работает на основе объектов модели. Что касается дат и времени, `select_date`, `select_time` и `select_datetime` - это скелетные хелперы, а `date_select`, `time_select` и `datetime_select` - это эквивалентные хелперы объекта модели.

Оба эти семейства хелперов создадут ряд списков выбора для различных компонентов (год, месяц, день и т.д.).

### Скелетные хелперы

Семейство хелперов `select_*` принимает как первый аргумент экземпляр `Date`, `Time` или `DateTime`, который используется как текущее выбранное значение. Можете опустить этот параметр в случае, если используется текущая дата. Например:

```erb
<%= select_date Date.today, prefix: :start_date %>
```

выведет (с опущенными для краткости начальными значениями пунктов списка)

```html
<select id="start_date_year" name="start_date[year]">
</select>
<select id="start_date_month" name="start_date[month]">
</select>
<select id="start_date_day" name="start_date[day]">
</select>
```

Эти элементы ввода приведут к тому, что `params[:start_date]` будет хэшем с ключами `:year`, `:month`, `:day`. Чтобы получить фактический объект `Date`, `Time` или `DateTime`, необходимо извлечь эти значения и передать их в подходящий конструктор, например:

```ruby
Date.civil(params[:start_date][:year].to_i, params[:start_date][:month].to_i, params[:start_date][:day].to_i)
```

Опция `:prefix` это ключ, используемый для получения хэша компонентов даты из хэша `params`. Здесь она была установлена как `start_date`, если опущена, то по умолчанию равна `date`.

### Хелперы объекта модели

`select_date` не очень хорошо работает с формами, обновляющими или создающими объекты Active Record, так как Active Record ожидает, что каждый элемент хэша `params` соответствует одному атрибуту. Хелперы объекта модели для даты и времени возвращает параметры со специальными именами, и когда Active Record видит параметры с такими именами, он знает, что они должны быть скомбинированы с другими параметрами, и передает конструктору значения, соответствующему типу столбца. Например:

```erb
<%= date_select :person, :birth_date %>
```

выдаст (с опущенными для краткости начальными значениями пунктов списка)

```html
<select id="person_birth_date_1i" name="person[birth_date(1i)]">
</select>
<select id="person_birth_date_2i" name="person[birth_date(2i)]">
</select>
<select id="person_birth_date_3i" name="person[birth_date(3i)]">
</select>
```

что приведет к такому результату в хэше `params`

```ruby
{'person' => {'birth_date(1i)' => '2008', 'birth_date(2i)' => '11', 'birth_date(3i)' => '22'}}
```

Когда это передано в `Person.new` (или `update`), Active Record отмечает, что все эти параметры должны быть использованы для конструирования атрибута `birth_date` и использует суффиксную информацию для определения, в каком порядке должен передать эти параметры в такие функции, как `Date.civil`.

### Общие опции

Оба семейства хелперов используют одинаковый базовый набор функций для генерации индивидуальных тегов select, таким образом, они оба принимают в основном одинаковые опции. В частности, по умолчанию Rails сгенерирует пункты списка года как текущий год плюс/минус пять лет. Если это неподходящий интервал, опции `:start_year` и `:end_year` переопределяют это. Для полного списка доступных опции обратитесь к [документации по API](http://api.rubyonrails.org/classes/ActionView/Helpers/DateHelper.html).

Как правило, следует использовать `date_select` при работе с объектами модели и `select_date` в иных случаях, например, таких как форма поиска, которая фильтрует результаты по дате.

### Индивидуальные компоненты

Иногда необходимо отобразить лишь одиночный компонент даты, такой как год или месяц. Rails предоставляет ряд хелперов для этого, по одному для каждого компонента `select_year`, `select_month`, `select_day`, `select_hour`, `select_minute`, `select_second`. Эти хелперы достаточно простые. По умолчанию они сгенерируют поле ввода, названное по имени компонента времени (например, "year" для `select_year`, "month" для `select_month` и т.д.), хотя это может быть переопределено в опции `:field_name`. Опция `:prefix` работает так же, как работает для `select_date` и `select_time` и имеет такое же значение по умолчанию.

Первый параметр определяет значение даты, которое будет предложено для выбора (соответствующий элемент может быть извлечен из экземпляра `Date`, `Time` или `DateTime`), либо сразу задается числовым значением. Например:

```erb
<%= select_year(2009) %>
<%= select_year(Time.new(2009)) %>
```

создадут одинаковый результат, и значение, выбранное пользователем, может быть получено как `params[:date][:year]`.

Загрузка файлов
---------------

Частой задачей является загрузка некоторого файла, аватарки или файла CSV, содержащего информацию для обработки. Самое важное, это помнить при загрузке файла, что атрибут enctype формы *должен* быть установлен как "multipart/form-data". Если используете `form_with` с `:model`, это будет выполнено автоматически. Если используете `form_with` без `:model`, нужно установить это самому, как в следующем примере.

Следующие две формы обе загружают файл.

```erb
<%= form_with(url: {action: :upload}, multipart: true) do %>
  <%= file_field_tag 'picture' %>
<% end %>

<%= form_with model: @person do |f| %>
  <%= f.file_field :picture %>
<% end %>
```

Rails предоставляет обычную пару хелперов: скелетный `file_field_tag` и модельно-ориентированный `file_field`. Как и следует ожидать, в первом случае загруженный файл находится в `params[:picture]`, а во втором случае - в `params[:person][:picture]`.

### Что имеем загруженным

Объект в хэше `params` - это экземпляр [`ActionDispatch::Http::UploadedFile`](http://api.rubyonrails.org/classes/ActionDispatch/Http/UploadedFile.html). Следующий образец кода сохраняет загруженное содержимое в `#{Rails.root}/public/uploads` под тем же именем, что и исходный файл.

```ruby
def upload
  uploaded_file = params[:picture]
  File.open(Rails.root.join('public', 'uploads', uploaded_file.original_filename), 'wb') do |file|
    file.write(uploaded_file.read)
  end
end
```

Как только файл был загружен, появляется множество потенциальных задач, начиная от того, где хранить файлы (на диске, Amazon S3 и т.д.), как связать их с моделями, изменить размер файлов изображений и сгенерировать миниатюры. Для помощи с такими задачами разработан [Active Storage](/active_storage_overview).

Настройка Form Builder
----------------------

Объект, который передается от `form_with` и `fields_for`, - это экземпляр [`ActionView::Helpers::FormBuilder`](http://api.rubyonrails.org/classes/ActionView/Helpers/FormBuilder.html). Form builder инкапсулирует представление элементов формы для отдельного объекта. Хотя, конечно, можно писать хелперы для своих форм обычным способом, так же как можно объявить подкласс `ActionView::Helpers::FormBuilder` и добавить хелперы туда. Например:

```erb
<%= form_with model: @person do |f| %>
  <%= text_field_with_label f, :first_name %>
<% end %>
```

может быть заменено этим

```erb
<%= form_with model: @person, builder: LabellingFormBuilder do |f| %>
  <%= f.text_field :first_name %>
<% end %>
```

через определение класса `LabellingFormBuilder` подобным образом:

```ruby
class LabellingFormBuilder < ActionView::Helpers::FormBuilder
  def text_field(attribute, options={})
    label(attribute) + super
  end
end
```

Если это используется часто, можно определить хелпер `labeled_form_with` который автоматически определяет опцию `builder: LabellingFormBuilder`:

```ruby
def labeled_form_with(model: nil, scope: nil, url: nil, format: nil, **options, &block)
  options.merge! builder: LabellingFormBuilder
  form_with model: model, scope: scope, url: url, format: format, **options, &block
end
```

Form builder также определяет, что произойдет, если вы сделаете

```erb
<%= render partial: f %>
```

Если `f` - это экземпляр `ActionView::Helpers::FormBuilder`, тогда это отрендерит партиал `form`, установив объект партиала как form builder. Если у form builder есть класс `LabellingFormBuilder`, тогда вместо него будет отрендерен партиал `labelling_form`.

(understanding-parameter-naming-conventions) Понимание соглашений по именованию параметров
------------------------------------------------------------------------------------------

Значения из форм могут быть на верхнем уровне хэша `params` или вложены в другой хэш. Например, в стандартном экшне `create` для модели Person, `params[:person]` будет обычно хэшем всех атрибутов для создания персоны. Хэш `params` может также содержать массивы, массивы хэшей и тому подобное.

В основном формы HTML не знают о каких-либо структурировании данных, все, что они генерируют - это пары имя-значение, где пары являются обычными строками. Массивы и хэши, которые можно увидеть в своем приложении, - это результат некоторых соглашений по именованию параметров, которые использует Rails.

### Базовые структуры

Две базовые структуры - это массивы и хэши. Хэши отражают синтаксис, используемый для доступа к значению в `params`. Например, если форма содержит

```html
<input id="person_name" name="person[name]" type="text" value="Henry"/>
```

хэш `params` будет содержать

```ruby
{'person' => {'name' => 'Henry'}}
```

и `params[:person][:name]` получит отправленное значение в контроллере.

Хэши могут быть вложены на столько уровней, сколько требуется, например:

```html
<input id="person_address_city" name="person[address][city]" type="text" value="New York"/>
```

вернет такой хэш `params`

```ruby
{'person' => {'address' => {'city' => 'New York'}}}
```

Обычно Rails игнорирует дублирующиеся имена параметра. Если имя параметра содержит пустой набор квадратных скобок `[]`, то они будут накоплены в массиве. Если нужно, чтобы пользователи могли оставить несколько телефонных номеров, можно поместить это в форму:

```html
<input name="person[phone_number][]" type="text"/>
<input name="person[phone_number][]" type="text"/>
<input name="person[phone_number][]" type="text"/>
```

Что приведет к тому, что `params[:person][:phone_number]` будет массивом, содержащим введенные телефонные номера.

### Комбинируем их

Можно смешивать и сочетать эти две концепции. Один из элементов хэша может быть массивом, как в предыдущем примере, или вы можете иметь массив хэшей. Например, форма может позволить вам создать любое количество адресов, повторяя следующий фрагмент кода

```html
<input name="person[addresses][][line1]" type="text"/>
<input name="person[addresses][][line2]" type="text"/>
<input name="person[addresses][][city]" type="text"/>
<input name="person[addresses][][line1]" type="text"/>
<input name="person[addresses][][line2]" type="text"/>
<input name="person[addresses][][city]" type="text"/>
```

Это приведет к тому, что `params[:person][:addresses]` будет массивом хэшей с ключами `line1`, `line2` и `city`.

Однако, имеется ограничение, в то время как хэши могут быть вложены произвольно, является допустимым только один уровень "массивности". Массивы обычно могут быть заменены хэшами; например, вместо массива объектов модели можно иметь хэш объектов модели с ключами, равными их id, индексу массива или любому другому параметру.

WARNING: Параметры массива не очень хорошо работают с хелпером `check_box`. В соответствии со спецификацией HTML, невыбранные чекбоксы не возвращают значения. Хелпер `check_box` обходит это, создавая вспомогательное скрытое поле с тем же именем. Если чекбокс не нажат, подтверждается только скрытое поле, а если он нажат, то они оба подтверждаются, но значение от чекбокса получает приоритет.

### Использование хелперов форм

Предыдущие разделы совсем не использовали хелперы Rails. Хотя можно создавать имена полей ввода самому и передавать их напрямую хелперам, таким как `text_field_tag`, Rails также предоставляет поддержку на более высоком уровне. В вашем распоряжении имеются два инструмента: параметр имени для `form_with` и `fields_for`, и опция `:index`, принимаемая этими хелперами.

Вы возможно захотите рендерить форму с набором полей ввода для каждого адреса человека. Например:

```erb
<%= form_with model: @person do |person_form| %>
  <%= person_form.text_field :name %>
  <% @person.addresses.each do |address| %>
    <%= person_form.fields_for address, index: address.id do |address_form| %>
      <%= address_form.text_field :city %>
    <% end %>
  <% end %>
<% end %>
```

Предположим, у кого-то есть два адреса с id 23 и 45, это создаст что-то подобное:

```html
<form accept-charset="UTF-8" action="/people/1" data-remote="true" method="post">
  <input name="_method" type="hidden" value="patch" />
  <input id="person_name" name="person[name]" type="text" />
  <input id="person_address_23_city" name="person[address][23][city]" type="text" />
  <input id="person_address_45_city" name="person[address][45][city]" type="text" />
</form>
```

Это приведет к тому, что хэш `params` будет выглядеть так

```ruby
{'person' => {'name' => 'Bob', 'address' => {'23' => {'city' => 'Paris'}, '45' => {'city' => 'London'}}}}
```

Rails знает, что все эти поля ввода должны быть частью хэша person, так как `fields_for` вызывается для первого form builder. Определив опцию `:index`, сообщается Rails, что вместо именования полей ввода `person[address][city]`, он должен вставить индекс, заключенный в [], между address и city. Это часто бывает полезно, так как тогда просто обнаружить, какая запись Address должна быть модифицирована. Также можно передавать числа с некоторым другим значением, строками или даже `nil` (который приведет к созданию параметра в массиве).

Чтобы создать более замысловатые вложения, можно явно указать первую часть имени поля ввода (`person[address]` в предыдущем примере):

```erb
<%= fields_for 'person[address][primary]', address, index: address.id do |address_form| %>
  <%= address_form.text_field :city %>
<% end %>
```

создаст такие поля ввода

```html
<input id="person_address_primary_1_city" name="person[address][primary][1][city]" type="text" value="Bologna" />
```

Как правило, конечное имя поля ввода - это сцепление имени, переданного в `fields_for`/`form_with`, значения индекса и имени атрибута. Можно также передать опцию `:index` прямо в хелперы, такие как `text_field`, но обычно будет меньше повторов, если определить это на уровне form builder, а не для отдельных элементах управления input.

Как ярлык вы можете добавить [] к имени и опустить опцию `:index`. Это то же самое, что определение `index: address.id`, таким образом

```erb
<%= fields_for 'person[address][primary][]', address do |address_form| %>
  <%= address_form.text_field :city %>
<% end %>
```

создаст абсолютно тот же результат, что и предыдущий пример.

Формы к внешним ресурсам
-------------------------

Хелперы форм Rails можно использовать и для создания форм для передачи данных внешнему ресурсу. Однако, иногда необходимо установить `authenticity_token` для ресурса; это можно осуществить, передав параметр `authenticity_token: 'your_external_token'` в опциях `form_with`:

```erb
<%= form_with url: 'http://farfar.away/form', authenticity_token: 'external_token' do %>
  Form contents
<% end %>
```

Иногда при отправке данных внешнему ресурсу, такому как платежный шлюз, поля, которые можно использовать в форме, ограничены внешним API, и генерация `authenticity_token` нежелательна. Чтобы не посылать токен, просто передайте `false` в опцию `:authenticity_token`:

```erb
<%= form_with url: 'http://farfar.away/form', authenticity_token: false do %>
  Form contents
<% end %>
```

Создание сложных форм
---------------------

Многие приложения выходят за рамки простых форм, редактирующих одиночные объекты. Например, при создании `Person` можно позволить пользователю (в той же самой форме) создать несколько записей адресов (домашний, рабочий и т.д.). При последующем редактировании этого person, пользователю должно быть доступно добавление, удаление или правка адреса, если это необходимо.

### Настройка модели

Active Record предоставляет поддержку на уровне модели с помощью метода `accepts_nested_attributes_for`:

```ruby
class Person < ApplicationRecord
  has_many :addresses, inverse_of: :person
  accepts_nested_attributes_for :addresses

end

class Address < ApplicationRecord
  belongs_to :person
end
```

Это создаст метод `addresses_attributes=` в `Person`, позволяющий создавать, обновлять и (опционально) уничтожать адреса.

### Вложенные формы

Следующая форма позволяет пользователю создать `Person` и связанные с ним адреса.

```html+erb
<%= form_with model: @person do |f| %>
  Addresses:
  <ul>
    <%= f.fields_for :addresses do |addresses_form| %>
      <li>
        <%= addresses_form.label :kind %>
        <%= addresses_form.text_field :kind %>

        <%= addresses_form.label :street %>
        <%= addresses_form.text_field :street %>
        ...
      </li>
    <% end %>
  </ul>
<% end %>
```

Когда связь принимает вложенные атрибуты, `fields_for` рендерит свой блок для каждого элемента связи. В частности, если у person нет адресов, он ничего не рендерит. Обычным паттерном для контроллера является построение одного или более пустых дочерних элементов, чтобы как минимум один набор полей был показан пользователю. Следующий пример покажет 2 набора полей адресов в форме нового person.

```ruby
def new
  @person = Person.new
  2.times { @person.addresses.build }
end
```

`fields_for` вкладывает form builder. Имя параметра будет таким, какое ожидает `accepts_nested_attributes_for`. К примеру, при создании пользователя с 2 адресами, отправленные параметры будут выглядеть так

```ruby
{
  'person' => {
    'name' => 'John Doe',
    'addresses_attributes' => {
      '0' => {
        'kind' => 'Home',
        'street' => '221b Baker Street'
      },
      '1' => {
        'kind' => 'Office',
        'street' => '31 Spooner Street'
      }
    }
  }
}
```

Ключи хэша `:addresses_attributes` не важны, они всего лишь должны быть различными для каждого адреса.

Если связанный объект уже сохранен, `fields_for` автоматически генерирует скрытое поле с `id` сохраненной записи. Это можно отключить, передав `include_id: false` в `fields_for`.

### Контроллер

Как обычно, в контроллере необходимо
[объявить разрешенные параметры](action_controller_overview.html#strong-parameters), перед их передачей в модель:

```ruby
def create
  @person = Person.new(person_params)
  # ...
end

private
  def person_params
    params.require(:person).permit(:name, addresses_attributes: [:id, :kind, :street])
  end
```

### Удаление объектов

Можно позволить пользователям удалять связанные объекты, передав `allow_destroy: true` в `accepts_nested_attributes_for`

```ruby
class Person < ApplicationRecord
  has_many :addresses
  accepts_nested_attributes_for :addresses, allow_destroy: true
end
```

Если хэш атрибутов для объекта содержит ключ `_destroy` со значением, вычисляющимся как 'true' (например, 1, '1', true или 'true'), тогда объект будет уничтожен. Эта форма позволяет пользователям удалять адреса:

```html+erb
<%= form_with model: @person do |f| %>
  Addresses:
  <ul>
    <%= f.fields_for :addresses do |addresses_form| %>
      <li>
        <%= addresses_form.check_box :_destroy %>
        <%= addresses_form.label :kind %>
        <%= addresses_form.text_field :kind %>
        ...
      </li>
    <% end %>
  </ul>
<% end %>
```

Не забудьте обновить список разрешенных параметров в вашем контроллере, а также включить туда поле `_destroy`:

```ruby
def person_params
  params.require(:person).
    permit(:name, addresses_attributes: [:id, :kind, :street, :_destroy])
end
```

### Предотвращение пустых записей

Часто полезно игнорировать наборы полей, которые пользователь не заполнял. Этим можно управлять, передав `:reject_if` proc в `accepts_nested_attributes_for`. Этот proc будет вызван для каждого хэша атрибутов, отправляемого формой. Если proc возвращает `false`, тогда Active Record не создаст связанный объект для этого хэша. Следующий пример пытается создать адрес, если установлен атрибут `kind`.

```ruby
class Person < ApplicationRecord
  has_many :addresses
  accepts_nested_attributes_for :addresses, reject_if: lambda {|attributes| attributes['kind'].blank?}
end
```

Вместо этого для удобства можно передать символ `:all_blank`, который создаст proc, который отвергнет записи, когда все атрибуты пустые, за исключением любого значения для `_destroy`.

### Добавление полей на лету

Вместо того, чтобы рендерить несколько наборов полей раньше времени, можно добавить их только тогда, когда пользователь нажимает на кнопку 'Добавить новый адрес'. Rails не предоставляет какой-либо встроенной поддержки для этого. При генерации новых наборов полей следует убедиться, что ключ связанного массива уникальный - наиболее распространенным выбором является текущий JavaScript date (миллисекунды после [epoch](https://en.wikipedia.org/wiki/Unix_time)).

Использование form_for и form_tag
---------------------------------

До того, как `form_with` был представлен в Rails 5.1, его функционал был разделен между `form_tag` и `form_for`. Последние сейчас мягко устаревшие. Документация по их использованию находится в [старых версиях этого руководства](https://github.com/morsbox/rusrails/blob/5.1/source/form_helpers.md).
