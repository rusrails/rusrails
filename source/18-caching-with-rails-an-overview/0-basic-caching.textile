h1. Основы кэширования

Это введение в три типа техники кэширования, предоставленных Rails по умолчанию, без каких-либо посторонних плагинов.

Перед тем, как начать, убедитесь, что +config.action_controller.perform_caching+ установлен +true+, если запущен режим development. Этот флаг обычно устанавливается в соответствующем config/environments/*.rb. По умолчанию кэширование отключено для development и test и включено для production.

<ruby>
config.action_controller.perform_caching = true
</ruby>

h4. Кэширование страницы

Кэширование страницы это механизм Rails, позволяющий запросу на сгенерированную страницу быть полностью обслуженным вебсервером (т.е. Apache или nginx) в принципе, без прохождения через стек Rails. Очевидно, это очень быстро. К сожалению, это не может быть применено к каждой ситуации (например, к страницам, требующим аутентификации), и, так как вебсервер фактически извлекает файл из файловой системы, придется иметь дело с вопросом времени хранения кэша.

Чтобы включить кэширование страниц, следует использовать метод +caches_page+.

<ruby>
class ProductsController < ActionController

  caches_page :index

  def index
    @products = Products.all
  end
end
</ruby>

Предположим, имеется контроллер +ProductsController+ и экшн +index+, отображающий все продукты. Как только кто-то впервые вызовет products/index, Rails создаст файл, названный +index.html+, и затем вебсервер будет видеть этот файл до того, как он передаст следующий запрос к products/index приложению на Rails.

По умолчанию директория кэша страниц устанавливается в Rails.public_path (которая обычно устанавливается как папка +public+), и это можно настроить, изменив конфигурационную настройку +config.action_controller.page_cache_directory+. Изменения умолчания с +public+ поможет избежать конфликт наименований, поскольку вы сможете захотеть разместить другой статичный html в +public+, но изменение этого потребует перенастройку веб сервера, чтобы он знал, откуда обслуживать кэшированные файлы.

Механизм кэширования страниц автоматически добавит расширение +.html+ к запросам страниц, не имеющих расширения, чтобы облегчить веб серверу поиск этих страниц, и это можно настроить, изменив конфигурационную настройку +config.action_controller.page_cache_extension+.

Для того, чтобы эта страница прекращала действие, когда добавляется новый продукт, можно изменить наш пример контроллера следующим образом:

<ruby>
class ProductsController < ActionController

  caches_page :index

  def index
    @products = Products.all
  end

  def create
    expire_page :action => :index
  end

end
</ruby>

Если желаете более сложную схему прекращения, можно использовать уборщики кэша для прекращения кэшированных объектов, если ситуация не меняется. Это раскроем в разделе про Уборщики.

NOTE: Кэширование страницы игнорирует все параметры. Например, +/products?page=1+ будет записан в файловую систему как +products.html+ без ссылки на параметр +page+. Следовательно, если кто-то позже запросит +/products?page=2+, ему будет возвращена кэшированная первая страница. Будьте осторожнее, когда кэшируете страницу с параметрами GET в URL!

INFO: Кэширование страниц запускается в последующем (after) фильтре. Следовательно, неверные запросы не будут ложные вхождения кэша, пока вы прерываете их. Обычно эту работу делает перенаправление в некоторых предварительных фильтрах, проверяющие предусловия запроса.

h4. Кэширование экшна

Одной из проблем кэширования страниц является то, что его нельзя использовать для страниц, требующих проверочный код, определяющий, разрешен ли доступ пользователю. И тут на помощь приходит кэширование экшна. Кэширование экшна работает как хэширование страницы, за исключением того, что входящий веб запрос идет от веб сервера в стек Rails и Action Pack, таким образом, до обслуживания кэша могут быть запущены предварительные (before) фильтры. Это позволит использовать аутентификацию и другие ограничения, и в то же время выводит результат из кэшированной копии.

Чистка кэша происходит так же, как и кэша страниц.

Если хотим, чтобы только авторизованные пользователи могли вызывать экшны в +ProductsController+.

<ruby>
class ProductsController < ActionController

  before_filter :authenticate
  caches_action :index

  def index
    @products = Product.all
  end

  def create
    expire_action :action => :index
  end

end
</ruby>

Также можно использовать +:if+ (или +:unless+), чтобы передать Proc, который определяет, когда экшн должен быть кэширован. Также можно использовать +:layout => false+, чтобы кэшировать без макета, таким образом, динамическая информация в макете, такая как имя вошедшего пользователя или предметы на карте, останется незакэшированной. Эта особенность доступна начиная с Rails 2.2.

Можете изменить путь к кэшу экшна по умолчанию, передав опцию +:cache_path+. Это будет передано непосредственно в +ActionCachePath.path_for+. Это удобно для экшнов с несколькими возможными маршрутами, которые должны кэшироваться различно. Если задан блок, он будет вызван текущим экземпляром контроллера.

Наконец, если используете memcached или Ehcache, можете также передать +:expires_in+. Фактически, все параметры, не используемые +caches_action+, посылаются в лежащее в основе хранилище кэша.

INFO: Кэширование страниц запускается в последующем (after) фильтре. Следовательно, неверные запросы не будут ложные вхождения кэша, пока вы прерываете их. Обычно эту работу делает перенаправление в некоторых предварительных фильтрах, проверяющие предусловия запроса.

h4. Кэширование фрагмента

Жить было бы прекрасно, если бы мы могли закэшировать весь контент страницы или экшна и обслуживать с ним всех. К сожалению, динамические веб приложения обычно создают страницы с рядом компонентов, не все из которых имеют сходные характеристики кэширования. Для устранения таких динамически создаваемых страниц, где различные части страниц нуждаются в кэшировании и прекращаются по-разному, Rails предоставляет механизм, названный Кэширование фрагмента.

Кэширование фрагмента позволяет фрагменту логики вьюхи быть обернутым в блок кэша и обслуженным из хранилища кэша для последующего запроса.

Как пример, если хотите показать все заказы, размещенные на веб сайте, в реальном времени и не хотите кэшировать эту часть страницы, но хотите кэшировать часть страницы, отображающей все доступные продукты, можете использовать следующий кусок кода:

<ruby>
<% Order.find_recent.each do |o| %>
  <%= o.buyer.name %> bought <%= o.product.name %>
<% end %>

<% cache do %>
  All available products:
  <% Product.all.each do |p| %>
    <%= link_to p.name, product_url(p) %>
  <% end %>
<% end %>
</ruby>

Блок cache в нашем примере будет привязан к вызвавшему его экшну и записан в тоже место, как кэш экшна, что означает, что если хотите кэшировать несколько фрагментов на экшн, следует предоставить +action_suffix+ в вызове cache:

<ruby>
<% cache(:action => 'recent', :action_suffix => 'all_products') do %>
  All available products:
</ruby>

Можете прекратить кэш, используя метод +expire_fragment+, подобно следующему:

<ruby>
expire_fragment(:controller => 'products', :action => 'recent', :action_suffix => 'all_products')
</ruby>

Если не хотите, чтобы блок cache привязывался к вызвавшему его экшну, можете также использовать глобально настроенные фрагменты, вызвав метод +cache+ с ключом, следующим образом:

<ruby>
<% cache('all_available_products') do %>
  All available products:
<% end %>
</ruby>

Этот фрагмент затем будет доступен во всех экшнах в +ProductsController+ c использованием ключа, и может быть прекращен тем же образом:

<ruby>
expire_fragment('all_available_products')
</ruby>

h4. Уборщики (sweepers)

Уборка кэша это механизм, позволяющий обойти кучу вызовов +expire_{page,action,fragment}+ в коде. Это осуществляется с помощью переноса всей работы, требуемой для прекращения кэшированного содержимого, в класс +ActionController::Caching::Sweeper+. Этот класс является обсервером, просматривающим изменения в объекте через колбэки, и когда изменение случается, он прекращает кэши, связанные с этим объектом, в фильтрах around или after.

Продолжая с нашим примером контроллера Product, мы можем переписать его с уборщиком, следующим образом:

<ruby>
class ProductSweeper < ActionController::Caching::Sweeper
  observe Product # This sweeper is going to keep an eye on the Product model

  # Если наш уборщик обнаружит, что Product был создан, вызываем это
  def after_create(product)
    expire_cache_for(product)
  end

  # Если наш уборщик обнаружит, что Product был обновлен, вызываем это
  def after_update(product)
    expire_cache_for(product)
  end

  # Если наш уборщик обнаружит, что Product был удален, вызываем это
  def after_destroy(product)
    expire_cache_for(product)
  end

  private
  def expire_cache_for(product)
    # Прекращает страницу list теперь, когда мы добавили новый продукт
    expire_page(:controller => 'products', :action => 'index')

    # Прекращает фрагмент
    expire_fragment('all_available_products')
  end
end
</ruby>

Можно отметить, что в уборщик передается фактический product, поэтому, если кэшируем экшн edit для каждого product, можно добавить метод прекращения, определяющий страницу, которая должна быть прекращена:

<ruby>
  expire_action(:controller => 'products', :action => 'edit', :id => product)
</ruby>

Затем добавим уборщик к контроллеру, чтобы сказать ему вызвать уборщик при вызове определенных экшнов. Поэтому, если мы хотим прекращать кэшированное содержимое для экшнов list и edit при вызове экшна create, мы должны сделать следующее:

<ruby>
class ProductsController < ActionController

  before_filter :authenticate
  caches_action :index
  cache_sweeper :product_sweeper

  def index
    @products = Product.all
  end

end
</ruby>

h4. Кэширование SQL

Кэширование запроса это особенность Rails, кэширующая результат выборки по каждому запросу. Если Rails встретит тот же запрос (query) на протяжения текущего запроса (request), он использует кэшированный результат, вместо того, чтобы снова сделать запрос к базе данных.

Например:

<ruby>
class ProductsController < ActionController

  def index
    # Запускаем поисковый запрос
    @products = Product.all

    ...

    # Снова запускаем тот же запрос
    @products = Product.all
  end

end
</ruby>

Второй раз к базе данных обращен тот же запрос, но он фактически не затронет базу данных. Результат, возвращенный первый раз от запроса, сохранится в кэше запроса (в памяти), и во второй раз будет получен из памяти.

Однако, важно отметить, что кэши запросов создаются в начале экшна и уничтожаются в конце этого экшна, и поэтому сохраняются только на протяжении экшна. Если хотите хранить результаты запроса более долгий период, воспользуйтесь низкоуровневым кэшированием Rails.
