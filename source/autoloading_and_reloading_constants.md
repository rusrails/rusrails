Автозагрузка и перезагрузка констант
====================================

Это руководство документирует, как работает автозагрузка и перезагрузка в режиме `zeitwerk`.

После его прочтения, вы узнаете:

* Об соответствующей настройке Rails
* О структуре проекта
* Об автоматической загрузке, перезагрузке и нетерпеливой загрузке
* О наследовании с единой таблицей
* И еще кое-что

--------------------------------------------------------------------------------

Введение
--------

INFO. Это руководство документирует автоматическую загрузку, перезагрузку и нетерпеливую загрузку в приложении Rails.

В обычных классах в программах на Ruby зависимости нужно загружать вручную. Например, следующий контроллер использует классы `ApplicationController` и `Post`, и обычно необходимо для них добавить вызовы `require`:

```ruby
# НЕ ДЕЛАЙТЕ ЭТОГО.
require 'application_controller'
require 'post'
# НЕ ДЕЛАЙТЕ ЭТОГО.

class PostsController < ApplicationController
  def index
    @posts = Post.all
  end
end
```

Но это не в случае приложений Rails, когда классы и модули приложения доступны везде:

```ruby
class PostsController < ApplicationController
  def index
    @posts = Post.all
  end
end
```

Характерные приложения Rails только используют вызовы `require` для загрузки вещей из директории `lib`, стандартной библиотеки Ruby, гемов Ruby, и так далее. То есть того, что не принадлежит путям автозагрузки, описанным ниже.

Для предоставления этой особенности, Rails управляет рядом загрузчиков [Zeitwerk](https://github.com/fxn/zeitwerk).

Структура проекта
-----------------

В приложении Rails имена файлов должны соответствовать константам, которые они определяют, а директории выступают как пространства имен.

Например, файл `app/helpers/users_helper.rb` должен определять `UsersHelper`, а файл `app/controllers/admin/payments_controller.rb` должен определять `Admin::PaymentsController`.

По умолчанию Rails настраивает Zeitwerk, чтобы преобразовывать имена файлов с помощью `String#camelize`. Например, он ожидает, что `app/controllers/users_controller.rb` определяет константу `UsersController`, так как это то, что возвращает `"users_controller".camelize`

Раздел _Настройка словообразования_ ниже документирует способы переопределения этих умолчаний.

Подробности в [документации Zeitwerk](https://github.com/fxn/zeitwerk#file-structure).

(autoload-paths) config.autoload_paths
--------------------------------------

Мы ссылаемся на список директорий приложения, содержимое которых должно быть автоматически загружено и (опционально) перезагружено, как _пути автозагрузки_. Например, `app/models`. Эти директории представляют корневое пространство имен: `Object`.

INFO. Пути автоматической загрузки называются _корневыми директориями_ в документации Zeitwerk, но в этом руководстве мы будем называть их "путь автозагрузки".

В пределах пути автозагрузки, имена файлов должны соответствовать константам, которые они определяют, как документировано [тут](https://github.com/fxn/zeitwerk#file-structure).

По умолчанию, пути автозагрузки приложения состоят из всех поддиректорий `app`, существующих во время загрузки приложения — за исключением `assets`, `javascript` и `views`, — плюс пути автозагрузки engine-ов, от которых оно может зависеть.

К примеру, если `UsersHelper` реализован в `app/helpers/users_helper.rb`, этот модуль автоматически загружаемый, и вам не нужно писать вызов `require` для него:

```bash
$ bin/rails runner 'p UsersHelper'
UsersHelper
```

Rails автоматически добавит пользовательские директории внутри `app` в пути автозагрузки. Например, если в вашем приложении есть `app/presenters`, или `app/services` и т.д., они будут добавлены в пути автозагрузки.

Массив путей автозагрузки может быть расширен с помощью добавления в `config.autoload_paths` в `config/application.rb` или `config/environments/*.rb`. Например:

```ruby
module MyApplication
  class Application < Rails::Application
    config.autoload_paths << "#{root}/extras"
  end
end
```

Также engine может добавлять в коде класса engine и в свой `config/environments/*.rb`.

WARNING. Пожалуйста, не изменяйте `ActiveSupport::Dependencies.autoload_paths`, публичный интерфейс для изменения путей автозагрузки — это `config.autoload_paths`.

WARNING: Вы не можете автоматически загружать код в путях автозагрузки, пока приложение загружается. В частности, непосредственно в `config/initializers/*.rb`. Пожалуйста, обратитесь к [_Автозагрузка при запуске приложения_](#autoloading-when-the-application-boots) ниже за правильными способами сделать это.

Пути автозагрузки управляются автозагрузчиком `Rails.autoloaders.main`.

config.autoload_once_paths
--------------------------

Также возможно автоматически загружать классы и модули без их перезагрузки. `autoload_once_paths` хранит код, который может быть автоматически загружен, но не будет перезагружен.

По умолчанию эта коллекция пустая, но ее можно расширить, добавив к `config.autoload_once_paths`. Это можно сделать в `config/application.rb` или `config/environments/*.rb`. Например:

```ruby
module MyApplication
  class Application < Rails::Application
    config.autoload_once_paths << "#{root}/app/serializers"
  end
end
```

Также engine может добавлять в коде класса engine и в свой `config/environments/*.rb`.

INFO. Если `app/serializers` добавлен `config.autoload_once_paths`, Rails больше не будет рассматривать его как путь автозагрузки, не смотря на то, что это пользовательская директория внутри `app`. Эта настройка переопределяет то правило.

Это важно для классов и модулей, которые кэшируются в местах, не являющихся перезагружаемыми, например в самом фреймворке Rails.

Например, сериализаторы Active Job сохраняются внутри Active Job:

```ruby
# config/initializers/custom_serializers.rb
Rails.application.config.active_job.custom_serializers << MoneySerializer
```

и сам Active Job не перезагружается при перезагрузке, это происходит только для кода приложения и engine-ов в путях автозагрузки.

Если сделать `MoneySerializer` перезагружаемым, это может быть озадачиваемым, так как перезагрузка отредактированной версии не будет влиять на объект этого класса, сохраненного в Active Job. Разумеется, если бы `MoneySerializer` был перезагружаемым, начиная с Rails 7 такой инициализатор выдал бы `NameError`.

Еще один пример, когда engine декорирует классы фреймворка:

```ruby
initializer "decorate ActionController::Base" do
  ActiveSupport.on_load(:action_controller_base) do
    include MyDecoration
  end
end
```

Тут объект модуля, хранящегося в `MyDecoration`, во время запуска инициализатора становится предком `ActionController::Base`, и перезагрузка `MyDecoration` бесполезна, она не повлияет на цепочку наследования.

Классы и модули из путей однократной автозагрузки могут быть автоматически загружены в `config/initializers`. Таким образом, с такой настройкой это будет работать:

```ruby
# config/initializers/custom_serializers.rb
Rails.application.config.active_job.custom_serializers << MoneySerializer
```

INFO: Технически можно автоматически загружать классы и модули, управляемые автозагрузчиком `once`, в любом инициализаторе, который запускается после `:bootstrap_hook`.

Пути однократной автозагрузки управляются `Rails.autoloaders.once`.

$LOAD_PATH{#load_path}
----------------------

Пути автозагрузки добавляются по умолчанию в `$LOAD_PATH`. Однако, внутренне Zeitwerk использует абсолютные имена файлов, и ваше приложение не должно иметь вызовов `require` для автоматически загружаемых файлов, таким образом, эти директории фактически тут не нужны. Вы можете их выключить с помощью флажка:

```ruby
config.add_autoload_paths_to_load_path = false
```

Это может немного ускорить правильные вызовы `require`, Поскольку будет меньше поиска. Также, если ваше приложение использует [Bootsnap](https://github.com/Shopify/bootsnap), это спасает библиотеку от построения ненужных индексов, приводя к снижению использования памяти.

Перезагрузка
------------

Rails автоматически перезагружает классы и модули, если файлы приложения в путях автозагрузки изменяются.

Если точнее, когда запущен веб сервер, и файлы приложения изменились, Rails выгружает все автоматически загруженные константы, управляемые автозагрузчиком `main`, непосредственно перед тем, как обрабатывать следующий запрос. Таким образом, классы или модули приложения, используемые в течение этого запроса, будут снова автоматически загружены, следовательно, будет взята их текущая реализация из файловой системы.

Перезагрузка может быть включена или отключена. Настройкой, контролирующей это поведение, является [`config.enable_reloading`][], которая по умолчанию `true` в режиме `development` и `false` по умолчанию в режиме `production`. Для обратной совместимости Rails также поддерживает `config.cache_classes`, которая эквивалентна `!config.enable_reloading`.

Rails по умолчанию использует событийный монитор файлов для обнаружения изменений файлов. Вместо этого можно настроить обнаружение изменений файлов, проходя по путям автозагрузки. Это контролируется настройкой [`config.file_watcher`][].

В консоли Rails нет активного наблюдателя файлов, вне зависимости от значения `config.enable_reloading`. Это потому, что обычно будет сбивать с толку, если код перезагрузится посреди консольной сессии. Как и в отдельном запросе, мы обычно хотим, чтобы сессия консоли обслуживалась постоянным, неизменным набором классов и модулей приложения.

Однако, можно принудительно перезагрузить, выполнив в консоли `reload!`:

```irb
irb(main):001:0> User.object_id
=> 70136277390120
irb(main):002:0> reload!
Reloading...
=> true
irb(main):003:0> User.object_id
=> 70136284426020
```

Как видите, объект класса, хранимый в константе `User`, отличается после перезагрузки.

[`config.enable_reloading`]: configuring.html#config-enable-reloading
[`config.file_watcher`]: configuring.html#config-file-watcher

### Перезагрузка и устаревшие объекты

Очень важно понимать, что в Ruby нет способа настоящей перезагрузки классов и методов в памяти, и это отражается везде, где она используется. Технически "выгрузка" класса `User` означает удаление константы `User` с помощью `Object.send(:remove_const, "User")`.

Например, вот сессия консоли Rails:

```irb
irb> joe = User.new
irb> reload!
irb> alice = User.new
irb> joe.class == alice.class
=> false
```

`joe` это экземпляр первоначального класса `User`. При перезагрузке константа `User` вычисляется как другой, перезагруженный класс. `alice` это экземпляр текущего класса, но не `joe` - его класс устарел. Можно снова определить `joe`, запустить подсессию IRB или просто запустить новую консоль вместо вызова `reload!`.

Другой ситуацией, в которой можно обнаружить эту особенность, является создание подкласса перезагружаемого класса в месте, которое не перезагружается:

```ruby
# lib/vip_user.rb
class VipUser < User
end
```

если `User` перезагружается, то, так как `VipUser` нет, суперклассом `VipUser` является оригинальный устаревший объект класса.

Вывод: **не кэшируйте перезагружаемые классы или модули**.

## (autoloading-when-the-application-boots) Автозагрузка при запуске приложения

Во время запуска приложения могут автоматически загружать из путей однократной автозагрузки, которые управляются автоматическим загрузчиком `once`. Обратитесь к разделу [`config.autoload_once_paths`](#config-autoload-once-paths) выше.

Однако, нельзя автоматически загружать из путей автозагрузки, управляемых автоматическим загрузчиком `main`. Это применимо к коду  инциализаторов в `config/initializers` как приложения, так и engine-ов.

Почему? Инициализаторы запускаются единожды, при запуске приложения. Если вы перезапускаете сервер, они запускаются снова в новом процессе, но перезагрузка не перезапускает сервер, и инициализаторы не запускаются снова again. Давайте рассмотрим два основных случая использования.

### Случай использования 1: Загрузка перезагружаемого кода во время запуска

#### Автозагрузка при запуске и на каждой перезагрузке

Давайте представим, что `ApiGateway` это перезагружаемый класс из `app/services`, управляемый автоматическим загрузчиком `main`, и вам необходимо настроить его узел при запуске приложения:

```ruby
# config/initializers/api_gateway_setup.rb
ApiGateway.endpoint = "https://example.com" # НЕ ДЕЛАЙТЕ ТАК
```

в перезагруженном `ApiGateway` узел будет `nil`, так как код выше не будет запущен повторно.

В течение запуска все еще можно делать подобные вещи, но их необходимо оборачивать в блок `to_prepare`, выполняемый при запуске и после каждой перезагрузки:

```ruby
# config/initializers/api_gateway_setup.rb
Rails.application.config.to_prepare do
  ApiGateway.endpoint = "https://example.com" # ПРАВИЛЬНО
end
```

NOTE: по историческим причинам этот колбэк может быть запущен дважды. Запускаемый код обязан быть идемпотентным.

#### Автозагрузка только при запуске

Перезагружаемые классы и модули также могут быть перезагружены в блоках `after_initialize`. Это выполняется при запуске, но не выполняется снова при перезагрузке. В некоторых исключительных случаях это может быть тем, что вам нужно.

Случаем использования для этого являются предполетные проверки:

```ruby
# config/initializers/check_admin_presence.rb
Rails.application.config.after_initialize do
  unless Role.where(name: "admin").exists?
    abort "The admin role is not present, please seed the database."
  end
end
```

### Случай использования 2: Загрузка кода, остающегося кэшированным, во время запуска

Некоторые конфигурации принимают объект класса или модуля, и они хранят его в месте, не являющемся перезагружаемым.

Например, промежуточная программа:

```ruby
config.middleware.use MyApp::Middleware::Foo
```

При перезагрузке стек промежуточных программ не затрагивается, таким образом, объект, хранимый в `MyApp::Middleware::Foo` во время запуска, остается там устаревшим.

Другим примером являются сериализаторы Active Job:

```ruby
# config/initializers/custom_serializers.rb
Rails.application.config.active_job.custom_serializers << MoneySerializer
```

Тот `MoneySerializer`, вычисленный во время инициализации, добавляется к пользовательским сериализаторам. Если он был перезагружен, изначальный объект все еще будет внутри Active Job, не отражая ваши изменения.

Еще одним примером являются railties или engine, декорирующие классы фреймворка, добавляя модули. Например, [`turbo-rails`](https://github.com/hotwired/turbo-rails) декорирует `ActiveRecord::Base` следующим образом:

```ruby
initializer "turbo.broadcastable" do
  ActiveSupport.on_load(:active_record) do
    include Turbo::Broadcastable
  end
end
```

Это добавляет объект модуля в цепочку наследования для `ActiveRecord::Base`. Изменения в `Turbo::Broadcastable` не несут эффекта при перезагрузке, цепочка наследования все еще будет изначальной.

Вывод: Эти классы или модули **нельзя перезагружать**.

Простейшим способом ссылаться на эти классы или модули в течение запуска, это определить их в директории, не принадлежащей путям перезагрузки. Например, `lib` - идиоматический выбор. По умолчанию она не принадлежит путям перезагрузки, но принадлежит `$LOAD_PATH`. Просто выполните обычный `require` чтобы загрузить их.

Как уже отмечено, другой опцией является нахождение их в директории, которая определена в путях однократной автозагрузки, и их автоматическая загрузка. За подробностями обратитесь к [разделу о config.autoload_once_paths](#config-autoload-once-paths).

Нетерпеливая загрузка
---------------------

В средах, подобных production, обычно лучше загрузить весь код приложения при запуске приложения. Нетерпеливая загрузка помещает все в память для немедленного обслуживания запросов, это также сочетается с механизмом [копирования при записи](https://ru.wikipedia.org/wiki/Копирование_при_записи).

Нетерпеливая загрузка контролируется флажком [`config.eager_load`][], который по умолчанию включен в режиме `production`.

Порядок, в котором файлы нетерпеливо загружаются, не определен.

В течение нетерпеливой загрузки, Rails вызывает `Zeitwerk::Loader.eager_load_all`. Это обеспечивает, что все зависимости от гемов, контролируемые Zeitwerk, будут также нетерпеливо загружены.

[`config.eager_load`]: configuring.html#config-eager-load

(single-table-inheritance) Наследование с единой таблицей
---------------------------------------------------------

Наследование с единой таблицей является особенностью, не очень сочетающейся с ленивой загрузкой. Причина в том, что его API должен быть способен подсчитать иерархию STI, чтобы работать корректно, в то время как ленивая загрузка откладывает загрузку классов, пока на них не сослались. Невозможно подсчитать то, на что еще не сослались.

В некотором смысле, приложениям нужно нетерпеливо загрузить иерархии STI, независимо от режима загрузки.

Конечно, если приложение нетерпеливо загружается при старте, это уже выполняется. Когда нет, на практике достаточно инициализировать типы, существующие в базе данных, что обычно достаточно в режимах разработки или тестирования. Одним из способов это сделать является включение модуля предварительной загрузки STI в директорию `lib`:

```ruby
module StiPreload
  unless Rails.application.config.eager_load
    extend ActiveSupport::Concern

    included do
      cattr_accessor :preloaded, instance_accessor: false
    end

    class_methods do
      def descendants
        preload_sti unless preloaded
        super
      end

      # Инициализирует как константу все типы, существующие в базе данных. There might be more on
      # На диске может быть и больше, но на практике это не имеет значения, пока речь идет о STI API.
      #
      # Предполагаем, что store_full_sti_class является true, по умолчанию.
      def preload_sti
        types_in_db = \
          base_class.
            select(inheritance_column).
            unscoped.
            distinct.
            pluck(inheritance_column).
            compact

        types_in_db.each do |type|
          logger.debug("Preloading STI type #{type}")
          type.constantize
        end

        self.preloaded = true
      end
    end
  end
end
```

и затем включите его в корневые классы STI вашего проекта:

```ruby
# app/models/shape.rb
require "sti_preload"

class Shape < ApplicationRecord
  include StiPreload # Только в корневом класса.
end
```

```ruby
# app/models/polygon.rb
class Polygon < Shape
end
```

```ruby
# app/models/triangle.rb
class Triangle < Polygon
end
```

Настройка словообразования
--------------------------

По умолчанию Rails использует `String#camelize`, чтобы узнать, какую константу должны определять данный файл или директория. Например, `posts_controller.rb` должен определять `PostsController`, так как это то, что возвращает `"posts_controller".camelize`.

Возможны случаи, когда имя определенного файла или директории не преобразуется в то, что вы хотите. Например, по умолчанию от `html_parser.rb` ожидается определение `HtmlParser`. Но что, если вы предпочитаете класс `HTMLParser`? Есть несколько способов настроить это.

Самым простым способом является определение аббревиатур:

```ruby
ActiveSupport::Inflector.inflections(:en) do |inflect|
  inflect.acronym "HTML"
  inflect.acronym "SSL"
end
```

Это глобально влияет на словообразование Active Support. Для некоторых приложений это отлично, но можно также настроить, как camelize отдельные базовые имена, независимо от Active Support, предоставив коллекцию переопределений в преобразователь по умолчанию:

```ruby
Rails.autoloaders.each do |autoloader|
  autoloader.inflector.inflect(
    "html_parser" => "HTMLParser",
    "ssl_error"   => "SSLError"
  )
end
```

Эта техника все еще зависит от `String#camelize`, хотя, так как преобразователь по умолчанию использует его как резервный. Если предпочитаете вообще не зависеть от словообразований Active Support, и получить полный контроль над словообразованием, настройте преобразователи быть экземплярами `Zeitwerk::Inflector`:

```ruby
Rails.autoloaders.each do |autoloader|
  autoloader.inflector = Zeitwerk::Inflector.new
  autoloader.inflector.inflect(
    "html_parser" => "HTMLParser",
    "ssl_error"   => "SSLError"
  )
end
```

Нет какой-либо глобальной конфигурации, которая может повлиять на указанные экземпляры; они детерминированы.

Можно даже определить собственный преобразователь для полной гибкости. Пожалуйста, обратитесь за подробностями к [документации Zeitwerk](https://github.com/fxn/zeitwerk#custom-inflector).

### Где должна храниться настройка словообразования?

Если приложение не использует автозагрузчик `once`, вышеприведенный код можно поместить в `config/initializers`. Например, `config/initializers/inflections.rb` для Active Support или `config/initializers/zeitwerk.rb` для остальных.

Приложения, использующие автозагрузчик `once`, должны переместить или загрузить эту конфигурацию в теле класса приложения в `config/application.rb`, так как автозагрузчик `once` использует словообразование рано в процессе запуска.

(autoloading-and-engines) Автоматическая загрузка и Engine
----------------------------------------------------------

Engine запускаются в контексте родительского приложения, и их код автоматически загружается, перезагружается и нетерпеливо загружается родительским приложением. Если приложение запускается в режиме `zeitwerk`, код engine загружается режимом `zeitwerk`. Если приложение запускается в режиме `classic`, код engine загружается режимом `classic`.

При запуске Rails, директории engine добавляются в пути автозагрузки, и, с точки зрения автозагрузчика, они не отличаются. Основные входные данные автозагрузчиков это пути автозагрузки, а принадлежат ли они дереву исходного кода приложения или дереву исходного кода engine, это не важно.

Например, приложение использует [Devise](https://github.com/heartcombo/devise):

```
% bin/rails runner 'pp ActiveSupport::Dependencies.autoload_paths'
[".../app/controllers",
 ".../app/controllers/concerns",
 ".../app/helpers",
 ".../app/models",
 ".../app/models/concerns",
 ".../gems/devise-4.8.0/app/controllers",
 ".../gems/devise-4.8.0/app/helpers",
 ".../gems/devise-4.8.0/app/mailers"]
 ```

Если engine контролирует режим автозагрузки родительского приложения, можно писать engine как обычно.

Однако, если engine поддерживает Rails 6 или Rails 6.1 и не контролирует его родительское приложение, ему необходимо быть готовым запускаться либо в режиме `classic`, либо в режиме `zeitwerk`. Нужно принять во внимание:

1. Если режиму `classic` может понадобиться вызов `require_dependency`, чтобы убедиться, что некоторая константа загружена в некотором месте, напишите его. Хотя он и не нужен в режиме `zeitwerk`, ничего страшного, он будет работать и в режиме `zeitwerk`.

2. Режим `classic` подчеркивает имена констант ("User" -> "user.rb"), а режим `zeitwerk` озаглавливает имена файлов ("user.rb" -> "User"). Они совпадают в большинстве случаев, но не всегда, когда есть ряд последовательных заглавных букв, как в "HTMLParser". Простейшим способом обеспечить совместимость является избегание таких имен. В данном случае выберите "HtmlParser".

3. В режиме `classic`, файлу `app/model/concerns/foo.rb` можно определять и `Foo`, и `Concerns::Foo`. В режиме `zeitwerk` имеется лишь одна опция: он должен определять  `Foo`. Для совместимости определяйте `Foo`.

Тестирование
------------

### Ручное тестирование

Задание `zeitwerk:check` проверяет, что дерево проекта следует ожидаемым соглашениям по именованию, и это удобно для ручных проверок. Например, если вы мигрируете с режима `classic` на `zeitwerk`, или чините что-то:

```
% bin/rails zeitwerk:check
Hold on, I am eager loading the application.
All is good!
```

Может быть дополнительный вывод, в зависимости от конфигурации приложения, но последний "All is good!" это то, что вам нужно.

### Автоматическое тестирование

Хорошей практикой является проверка в тестовом наборе, что проект корректно нетерпеливо загружается.

Это покрывает соглашения по именованию Zeitwerk и другие возможные условия ошибки. Обратитесь к [разделу о тестировании нетерпеливой загрузки](/testing#testing-eager-loading) в руководстве [_Тестирование приложений на Rails_](/testing).

Разрешение проблем
------------------

Лучшим способом понять, что делают загрузчики, является наблюдение за их активностью.

Простейший способ для этого - включить

```ruby
Rails.autoloaders.log!
```

в `config/application.rb` после загрузки умолчаний для фреймворка. Это напечатает трейсы в стандартный вывод.

Если предпочитаете логирование в файл, настройте так:

```ruby
Rails.autoloaders.logger = Logger.new("#{Rails.root}/log/autoloading.log")
```

Логгер Rails пока еще не доступен при запуске `config/application.rb`. Если предпочитаете использовать логгер Rails, сконфигурируйте эту настройку в инициализаторе:

```ruby
# config/initializers/log_autoloaders.rb
Rails.autoloaders.logger = Rails.logger
```

Rails.autoloaders
-----------------

Экземпляры Zeitwerk, управляющие вашим приложением, доступны в

```ruby
Rails.autoloaders.main
Rails.autoloaders.once
```

Предикат

```ruby
Rails.autoloaders.zeitwerk_enabled?
```

все еще доступен в приложениях Rails 7, и возвращает `true`.
