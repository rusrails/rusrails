# Как использовать файлопровод (Asset Pipeline)

В прежних версиях Rails, все ресурсы были расположены в субдиректориях `public`, таких как `images`, `javascripts` и `stylesheets`. Сейчас, с файлопроводом, предпочтительным местом размещения для этих ресурсов стала директория `app/assets`. Файлы в этой директории отдаются промежуточной программой Sprockets, включенной в гем sprockets.

Ресурсы все еще могут быть размещены в `public`. Любой ресурс в `public` будет отдан как статичный файл приложением или веб-сервером. Следует использовать `app/assets` для файлов, которые должны пройти некоторую предварительную обработку перед тем, как будут отданы.

По умолчанию в production Rails прекомпилирует эти файлы в `public/assets`. Прекомпилированные копии затем отдаются веб-сервером как статичные ресурсы. Файлы в `app/assets` никогда не отдаются напрямую в production.

### Ресурсы конкретного контроллера

При генерации скаффолда или контроллера, Rails также генерирует файл JavaScript (или файл CoffeeScript, если гем `coffee-rails` имеется в `Gemfile`) и файл СSS (или файл SCSS, если `sass-rails` имеется в `Gemfile`) для этого контроллера.

Например, если генерируете `ProjectsController`, Rails также добавит новый файл `app/assets/javascripts/projects.js.coffee` и еще один `app/assets/stylesheets/projects.css.scss`. По умолчанию эти файлы будут готовы к немедленному использованию вашим приложением, с помощью директивы `require_tree`. Смотрите [Файлы манифеста и директивы](#manifest-files-and-directives) о подробностях require_tree.

Опционально можно включить таблицы стиоей и файлы JavaScript конкретного контроллера только для их соответствующих контроллеров, используя следующее: `<%= javascript_include_tag params[:controller] %>` или `<%= stylesheet_link_tag params[:controller] %>`. Однако, убедитесь, что не используете директиву `require_tree`, так как это приведет к тому, что ресурсы будут включены более одного раза.

WARNING: При использовании прекомпиляции ресурсов (по умолчанию в production), необхоимо убедиться, что ресурсы контроллера будут прекомпилированы при варианте загрузки их на основе страницы. По умолчанию файлы .coffee и .scss не будут прекомпилированы отдельно. Это приведет к видимости правильной работы при разработке, так как эти файлы будут работать, так как ресурсы компилируются на лету. Однако, при запуске на production, вы увидите ошибки 500, так как компиляция на лету по умолчанию отключена. Смотрите [Прекомпиляция ресурсов](/asset-pipeline/in-production) о подробностях работы прекомпиляции.

NOTE: Вам необходим runtime, поддерживаемый ExecJS, чтобы использовать CoffeeScript. Если используете Mac OS X или Windows, у вас уже имеется JavaScript runtime, установленный в операционной системе. Обратитесь к документации по [ExecJS](https://github.com/sstephenson/execjs#readme), чтобы узнать обо всех поддерживаемых JavaScript runtime-ах.

Отключить создание ресурсов при генерации контроллера можно, добавив следующее в конфигурацию `config/application.rb`:

```ruby
config.generators do |g|
  g.assets false
end
```

### Организация ресурсов

Ресурсы файлопровода могут быть размещены в приложении в одном из этих трех мест: `app/assets`, `lib/assets` или `vendor/assets`.

`app/assets` предназначено для ресурсов, принадлежащих приложению, таких как изображения, файлы JavaScript или таблицы стилей, изготовленные специально для приложения.

`lib/assets` предназначено для кода ваших собственных библиотек, которые не вписываются в сферу применения приложения или эти библиотеки используются в нескольких приложениях.

`vendor/assets` предназначено для ресурсов, принадлежащих сторонним субъектам, таких как код плагинов JavaScript и фреймворки CSS.

#### Пути поиска

Когда к файлу обращаются из манифеста или хелпера, Sprockets ищет в трех дефолтных местах размещения ресурсов для этого.

Дефолтные места следующие: `app/assets/images` и поддиректории `javascripts` и `stylesheets` во всех трех метах размещения ресурсов, но эти поддиректории не особенные. Поиск будет вестись по любому пути в `assets/*`.

Для примера, на эти файлы:

```
app/assets/javascripts/home.js
lib/assets/javascripts/moovinator.js
vendor/assets/javascripts/slider.js
vendor/assets/somepackage/phonebox.js
```

можно сослаться в манифесте таким образом:

```js
//= require home
//= require moovinator
//= require slider
//= require phonebox
```

Ресурсы в поддиректориях также доступны.

```
app/assets/javascripts/sub/something.js
```

доступен как:

```js
//= require sub/something
```

Можно просмотреть путь поиска, проинспектировав `Rails.application.config.assets.paths` в консоли Rails.

Помимо стандартных путей `assets/*` в файлопровод могут быть добавлены дополнительные (полные) пути в `config/application.rb`. Например:

```ruby
config.assets.paths << Rails.root.join("lib", "videoplayer", "flash")
```

Пути обходятся в том порядке, в котором они выводятся в пути поиска. По умолчанию это означает, что имеют преимущество файлы в `app/assets`, они перекроют соотвествующие пути в `lib` и `vendor`.

Важно заметить, что если хотите сослаться на что-то еще, в прекомпиляционный массив должен быть добавлен манифест, или оно не будет доступно в среде production.

#### Использование индексных файлов

Sprockets использует файлы с именем `index` (с соответствующим расширением) для специальных целей.

Например, если имеется бибилиотека jQuery с множеством модулей, хранящаяся в `lib/assets/library_name`, файл `lib/assets/library_name/index.js` служит манифестом для всех файлов в этой библиотеке. Этот файл может включать список всех требуемых файлов в нужном порядке, или просто директиву `require_tree`.

Библиотека в целом может быть доступна из манифеста приложения следующим образом:

```js
//= require library_name
```

Это упрощает поддержку и сохраняет чистоту, позволяя коду быть сгруппированным перед включением где-нибудь еще.

### Кодирование ссылок на ресурсы

Sprockets не добавляет какие-либо новые методы для доступа к вашим ресурсам - используйте знакомые методы `javascript_include_tag` и `stylesheet_link_tag`.

```erb
<%= stylesheet_link_tag "application" %>
<%= javascript_include_tag "application" %>
```

В обычных вьюхах можно получить доступ к изображениям в директории `assets/images` следующим образом:

```erb
<%= image_tag "rails.png" %>
```

При условии, что файлопровод включен в вашем приложении (и не отключен в контексте текущей среды), этот файл будет отдан Sprockets'ом. Если файл существует в `public/assets/rails.png`, он будет отдан веб-сервером.

Кроме того, запрос файла с хешем MD5, такого как `public/assets/rails-af27b6a414e6da00003503148be9b409.png` будет обработан тем же образом. Как генерируются эти хеши раскрыто в позже в этом руководстве в разделе [В production](/asset-pipeline/in-production).

Sprockets также будет смотреть в путях, определенных в `config.assets.paths`, включающие стандартные пути приложения и любой путь, добавленный engine-ами Rails.

Изображения также могут быть организованы в субдиректории и могут быть доступны с помощью указания имени директории в теге:

```erb
<%= image_tag "icons/rails.png" %>
```

WARNING: Если вы прекомпилируете ресурсы (смотрите раздел [В production](/asset-pipeline/in-production) далее), связывание с несуществующим ресурсом вызовет исключение на вызывающей странице. Это включает связывание с пустой строкой. Поэтому будьте острожны при использовании `image_tag` и других хелперов с данными, предоставленными пользователями.

#### CSS и ERB

Файлопровод автоматически вычислят ERB. Это означает, что, если добавить расширение `erb` к ресурсу CSS (например, `application.css.erb`), тогда будут доступны хелперы, такие как `asset_path`, в правилах вашего CSS:

```css
.class { background-image: url(<%= asset_path 'image.png' %>) }
```

Это записывает путь к определенному указанному ресурсу. Этот пример имеет смысл если имеется изображение в одном из путей загрузки ресурсов, такое как `app/assets/images/image.png`, на которое тут будет ссылка. Если это изображение уже имеется в `public/assets` как файл с меткой, то будет ссылка на него.

Если хотите использовать [data URI](http://ru.wikipedia.org/wiki/Data:_URL) - метод встравивания данных изображения непосредственно в файл CSS - используйте хелпер `asset_data_uri`.

```css
#logo { background: url(<%= asset_data_uri 'logo.png' %>) }
```

Это вставит правильно отформатированный URI в код CSS.

Отметьте, что закрывающий тег не может быть стиля `-%>`.

#### CSS и Sass

При использовании файлопровода пути к ресурсам должны быть переписаны и `sass-rails` представляет хелперы `-url` и `-path` helpers (через дефис в Sass, через подчеркивание в Ruby) для следующих типов ресурсов: изображение, шрифт, видео, аудио, JavaScript и таблица стилей.

* `image-url("rails.png")` становится `url(/assets/rails.png)`
* `image-path("rails.png")` становится `"/assets/rails.png"`.

Также может быть использована более общая форма, но должны быть указаны и путь к ресурсу, и его класс:

* `asset-url("rails.png", image)` становится `url(/assets/rails.png)`
* `asset-path("rails.png", image)` становится `"/assets/rails.png"`

#### JavaScript/CoffeeScript и ERB

Если добавить расширение `erb` к ресурсу JavaScript, сделав его чем-то вроде `application.js.erb`, можно использовать хелпер `asset_path` в коде вашего JavaScript:

```erb
$('#logo').attr({
  src: "<%= asset_path('logo.png') %>"
});
```

Это записывает путь к определенному указанному ресурсу.

Подобным образом можно использовать хелпер `asset_path` в файлах CoffeeScript с расширением `erb` (т.е. `application.js.coffee.erb`):

```js
$('#logo').attr src: "<%= asset_path('logo.png') %>"
```

### (manifest-files-and-directives) Файлы манифеста и директивы

Sprockets использует файлы манифеста для определения, какие ресурсы включать и отдавать. Эти файлы манифеста содержат _директивы_ - инструкции, говорящие Sprockets, какие файлы требуются для создания отдельного файла CSS или JavaScript. С помощью этих директив Sprockets загружает указанные файлы, при необходимости их обрабатывает, соединяет в отдельный файл и затем сжимает их (если `Rails.application.config.assets.compress` равно true). При отдаче одного файла, а не нескольких, время загрузки страницы значительно уменьшается, поскольку браузер делает меньше запросов. Компрессия также уменьшает размер файла, что позволяет браузеру быстрее его скачать.

К примеру, новое приложение Rails включает дефолтный файл `app/assets/javascripts/application.js`, содержащий следующие строки:

```js
// ...
//= require jquery
//= require jquery_ujs
//= require_tree .
```

В файлах JavaScript директивы начинаются с `//=`. В этом примере файл использует директивы `require` и `require_tree`. Директива `require` используется, чтобы указать Sprockets на требуемые файлы. Здесь затребованы файлы `jquery.js` и `jquery_ujs.js`, которые доступны где-то по пути поиска для Sprockets. Не нужно явно указывать расширение. Sprockets предполагает, что вы требуете файл `.js`, когда выполняется из файла `.js`.

Директива `require_tree` говорит Sprockets рекурсивно включить _все_ файлы JavaScript в указанной директории в результирующий файл. Эти пути должны быть определены только относительно файла манифеста. Также можно использовать директиву `require_directory`, включающая все файлы JavaScript только в определенной директории, без рекурсии .

Директивы обрабатываются сверху вниз, но порядок, в котором файлы включаются с помощью `require_tree` не определен. Не следует полагаться на какой-то определенный порядок при ее использовании. Если хотите убедиться, что какой-то определенный JavaScript закончится до некоторого другого в объединенном файле, затребуйте нужный файл раньше в манифесте. Отметьте, что семейство директив `require` предотвращает от повторного включения файлов в результирующий файл.

Rails также создает дефолтный файл `app/assets/stylesheets/application.css`, содержащий эти строки:

```css
/* ...
*= require_self
*= require_tree .
*/
```

Директивы, работающие в файлах JavaScript, также работают в таблицах стилей (хотя, очевидно, включая таблицы стилей вместо JavaScript). В манифесте CSS директива `require_tree` работает так же, как и для JavaScript, включающая все таблицы стилей из текущей директории.

В этом примере использована `require_self`. Это помещает CSS, содержащийся в файле (если есть) в месте расположения вызова `require_self`. Если `require_self` вызывается более одного раза, учитывается только последний вызов.

NOTE. Если хотите использовать несколько файлов Sass, как правило следует использовать [правило Sass `@import`](http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#import) вместо директив Sprockets. При использовании директив Sprockets все файлы существуют в своей собственной области видимости, что делает переменные или примеси (mixins) доступными только в документе, их определяющем.

Можно иметь сколько угодно манифестов. Для примера, манифесты `admin.css` и `admin.js` могут содержать файлы JS и CSS, используемые для административного раздела приложения.

Применяются те же оговорки о порядке следования, что сделаны выше. В частности, можно определить отдельные файлы и порядок, в котором они будут компилироваться. Например, можно соединить три файла CSS вместе следующим образом:

```css
/* ...
*= require reset
*= require layout
*= require chrome
*/
```

### Предварительная обработка

Расширение, использованное у ресурса, определяет, какая будет применена предварительная обработка. Когда генерируется скаффолд или контроллер с помощью дефолтного набора гемов Rails, создадутся файл CoffeeScript и файл SCSS вместо обычных файлов JavaScript и CSS. В использованном ранее примере был контроллер с именем "projects", который создал файлы `app/assets/javascripts/projects.js.coffee` и `app/assets/stylesheets/projects.css.scss`.

Когда запрашиваются эти файлы, они обрабатываются процессорами, представленными гемами `coffee-script` и `sass`, а затем отдаются браузеру как JavaScript и CSS соответственно.

Может быть запрошен дополнительный уровень обработки, если добавить другое расширение, каждое расширение обрабатывается в порядке справа налево. Их следует использовать в том порядке, в котором должна быть применена обработка. Например, таблица стилей с именем `app/assets/stylesheets/projects.css.scss.erb` сначала обрабатывается как ERB, затем SCSS и, наконец, отдается как CSS. То же самое применимо к файлу JavaScript - `app/assets/javascripts/projects.js.coffee.erb` обрабатывается как ERB, затем CoffeeScript и отдается как JavaScript.

Помните, что порядок этих препроцессоров важен. Например, если вызовите свой файл JavaScript `app/assets/javascripts/projects.js.erb.coffee`, то он будет сначала обработан интерпретатором CoffeeScript, который не понимает ERB, и, следовательно, возникнут проблемы.
