h1. Нересурсные маршруты

В дополнению к ресурсному роутингу, Rails поддерживает роутинг произвольных URL к экшнам. Тут не будет групп маршрутов, создаваемых автоматически ресурсным роутингом. Вместо этого вы должны настроить каждый маршрут вашего приложения отдельно.

Хотя обычно следует пользоваться ресурсным роутингом, есть много мест, где более подходит простой роутинг. Не стоит пытаться заворачивать каждый кусочек своего приложения в ресурсные рамки, если он плохо поддается.

В частности, простой роутинг облегчает привязку наследуемых URL к новым экшнам Rails.

h4. Обязательные параметры

При настройке обычного маршрута вы предоставляете ряд символов, которые Rails связывает с частями входящего запроса HTTP. Два из этих символов специальные: +:controller+ связывает с именем контроллера в приложении, и +:action+ связывает с именем экшна в контроллере. Например, рассмотрим один из дефолтных маршрутов Rails:

<ruby>
match ':controller(/:action(/:id))'
</ruby>

Если входящий запрос +/photos/show/1+ обрабатывается этим маршрутом (так как не встретил какого-либо соответствующего маршрута в файле до этого), то результатом будет вызов экшна +show+ в +PhotosController+, и результирующий параметр (1) будет доступен как +params[:id]+. Этот маршрут также свяжет входящий запрос +/photos+ с +PhotosController+, поскольку +:action+ и +:id+ необязательные параметры, обозначенные скобками.

h4. Динамические сегменты

Можете настроить сколько угодно динамических сегментов в обычном маршруте. Всё, кроме +:controller+ или +:action+, будет доступно для соответствующего экшна как часть хэша params. Таким образом, если настроите такой маршрут:

<ruby>
match ':controller/:action/:id/:user_id'
</ruby>

Входящий URL +/photos/show/1/2+ будет направлен на экшн +show+ в +PhotosController+. +params[:id]+ будет установлен как "1", и +params[:user_id]+ будет установлен как "2".

NOTE: Нельзя использовать +namespace+ или +:module+ вместе с сегментом пути +:controller+. Если это нужно, используйте ограничение на :controller, которое соответствует требуемому пространству имен, т.е.:

<ruby>
match ':controller(/:action(/:id))', :controller => /admin\/[^\/]+/
</ruby>

h4. Статичные сегменты

Можете определить статичные сегменты при создании маршрута:

<ruby>
match ':controller/:action/:id/with_user/:user_id'
</ruby>

Этот маршрут соответствует путям, таким как +/photos/show/1/with_user/2+. В этом случае +params+ будет <tt>{ :controller => "photos", :action => "show", :id => "1", :user_id => "2" }</tt>.

h4. Параметры строки запроса

+params+ также включает любые параметры из строки запроса. Например, с таким маршрутом:

<ruby>
match ':controller/:action/:id'
</ruby>

Входящий путь +/photos/show/1?user_id=2+ будет направлен на экшн +show+ контроллера +Photos+. +params+ будет <tt>{ :controller => "photos", :action => "show", :id => "1", :user_id => "2" }</tt>.

h4. Определение значений по умолчанию

В маршруте не обязательно явно использовать символы +:controller+ и +:action+. Можете предоставить их как значения по умолчанию:

<ruby>
match 'photos/:id' => 'photos#show'
</ruby>

С этим маршрутом Rails направит входящий путь +/photos/12+ на экшн +show+ в +PhotosController+.

Также можете определить другие значения по умолчанию в маршруте, предоставив хэш для опции +:defaults+. Это также относится к параметрам, которые не определены как динамические сегменты. Например:

<ruby>
match 'photos/:id' => 'photos#show', :defaults => { :format => 'jpg' }
</ruby>

Rails направит +photos/12+ в экшн +show+ +PhotosController+, и установит +params[:format]+ как +jpg+.

h4. Именование маршрутов

Можно определить имя для любого маршрута, используя опцию +:as+.

<ruby>
match 'exit' => 'sessions#destroy', :as => :logout
</ruby>

Это создаст +logout_path+ и +logout_url+ как именнованные хелперы в вашем приложении. Вызов +logout_path+ вернет +/logout+

h4. Ограничения метода HTTP

Можете использовать опцию +:via+ для ограничения запроса одним или несколькими методами HTTP:

<ruby>
match 'photos/show' => 'photos#show', :via => :get
</ruby>

Также имеется короткая версия этого:

<ruby>
get 'photos/show'
</ruby>

Также можно разрешить более одного метода в одном маршруте:

<ruby>
match 'photos/show' => 'photos#show', :via => [:get, :post]
</ruby>

h4. Ограничения сегмента

Можно использовать опцию +:constraints+ для соблюдения формата динамического сегмента:

<ruby>
match 'photos/:id' => 'photos#show', :constraints => { :id => /[A-Z]\d{5}/ }
</ruby>

Этот маршрут соответствует путям, таким как +/photos/A12345+. Можно выразить более кратко тот же маршрут следующим образом:

<ruby>
match 'photos/:id' => 'photos#show', :id => /[A-Z]\d{5}/
</ruby>

+:constraints+ принимает регулярное выражение c ограничением, что якоря regexp не могут использоваться. Например, следующий маршрут не работает:

<ruby>
match '/:id' => 'posts#show', :constraints => {:id => /^\d/}
</ruby>

Однако отметьте, что нет необходимости использовать якоря, поскольку все маршруты заякорены изначально.

Например, следующие маршруты приведут к +posts+ со значениямм +to_param+ такими как +1-hello-world+, которые всегда начинаются с цифры, к +users+ со значениями +to_param+ такими как +david+, никогда не начинающимися с цифры, разделенные в корневом пространстве имен:

<ruby>
match '/:id' => 'posts#show', :constraints => { :id => /\d.+/ }
match '/:username' => 'users#show'
</ruby>

h4. Ограничения, основанные на запросе

Также можно ограничить маршрут, основываясь на любом методе в объекте "Request":/action-controller-overview/the-request-and-response-objects, который возвращает +String+.

Ограничение, основанное на запросе, определяется так же, как и сегментное ограничение:

<ruby>
match "photos", :constraints => {:subdomain => "admin"}
</ruby>

Также можно определить ограничения в форме блока:

<ruby>
namespace :admin do
  constraints :subdomain => "admin" do
    resources :photos
  end
end
</ruby>

h4. Продвинутые ограничения

Если имеется более продвинутое ограничение, можете предоставить объект, отвечающий на +matches?+, который будет использовать Rails. Скажем, вы хотите направить всех пользователей через черный список в +BlacklistController+. Можно сделать так:

<ruby>
class BlacklistConstraint
  def initialize
    @ips = Blacklist.retrieve_ips
  end

  def matches?(request)
    @ips.include?(request.remote_ip)
  end
end

TwitterClone::Application.routes.draw do
  match "*path" => "blacklist#index",
    :constraints => BlacklistConstraint.new
end
</ruby>

h4. Подстановка маршрутов

Подстановка маршрутов это способ указать, что определенные параметры должны соответствовать остальным частям маршрута. Например

<ruby>
match 'photos/*other' => 'photos#unknown'
</ruby>

Этот маршрут будет соответствовать +photos/12+ или +/photos/long/path/to/12+, установив +params[:other]+ как +"12"+, или +"long/path/to/12"+.

Динамические сегменты могут быть где угодно в маршруте. Например

<ruby>
match 'books/*section/:title' => 'books#show'
</ruby>

будет соответствовать +books/some/section/last-words-a-memoir+ с +params[:section]+ равным +"some/section"+, и +params[:title]+ равным +"last-words-a-memoir"+.

На самом деле технически маршрут может иметь более одного динамического сегмента, matcher назначает параметры интуитивным образом. Для примера

<ruby>
match '*a/foo/*b' => 'test#index'
</ruby>

будет соответствовать +zoo/woo/foo/bar/baz+ с +params[:a]+ равным +"zoo/woo"+, и +params[:b]+ равным +"bar/baz"+.

NOTE: Начиная с Rails 3.1, динамические маршруты всегда будут соответствовать опциональному формату сегмента по умолчанию. Например, если есть такой маршрут:

<ruby>
match '*pages' => 'pages#show'
</ruby>

NOTE: Запросив +"/foo/bar.json"+, ваш +params[:pages]+ будет равен +"foo/bar"+ с форматом запроса JSON. Если вам нужно вернуть старое поведение 3.0.x, можете предоставить +:format => false+ вот так:

<ruby>
match '*pages' => 'pages#show', :format => false
</ruby>

NOTE: Если хотите сделать сегмент формата обязательным, чтобы его нельзя было опустить, укажите +:format => true+ подобным образом:

<ruby>
match '*pages' => 'pages#show', :format => true
</ruby>

h4. Перенаправление

Можно перенаправить любой путь на другой путь, используя хелпер +redirect+ в вашем роутере:

<ruby>
match "/stories" => redirect("/posts")
</ruby>

Также можно повторно использовать динамические сегменты для соответствия пути, на который перенаправляем:

<ruby>
match "/stories/:name" => redirect("/posts/%{name}")
</ruby>

Также можно предоставить блок для перенаправления, который получает params и (опционально) объект request:

<ruby>
match "/stories/:name" => redirect {|params| "/posts/#{params[:name].pluralize}" }
match "/stories" => redirect {|p, req| "/posts/#{req.subdomain}" }
</ruby>

Пожалуйста, отметьте, что это перенаправление является 301 "Moved Permanently". Учтите, что некоторые браузеры или прокси серверы закэшируют этот тип перенаправления, сделав старые страницы недоступными.

Во всех этих случаях, если не предоставить предшествующий хост (+http://www.example.com+), Rails возьмет эти детали из текущего запроса.

h4. Роутинг к приложениям Rack

Вместо String, подобной +"posts#index"+, соответствующей экшну +index+ в +PostsController+, можно определить любое "приложение Rack":http://guides.rubyonrails.org/rails_on_rack.html как конечную точку совпадения.

<ruby>
match "/application.js" => Sprockets
</ruby>

Пока +Sprockets+ отвечает на +call+ и возвращает +[status, headers, body]+, роутер не будет различать приложение Rack и экшн.

NOTE: Для любопытства, +"posts#index"+ фактически расширяется до +PostsController.action(:index)+, который возвращает валидное приложение Rack.

h4. Использование +root+

Можно определить, с чем Rails должен связать +"/"+ с помощью метода +root+:

<ruby>
root :to => 'pages#main'
</ruby>

Следует поместить маршрут +root+ в начало файла, поскольку это наиболее популярный маршрут и должен быть проверен первым. Также необходимо удалить файл +public/index.html+, чтобы корневой маршрут заработал.
