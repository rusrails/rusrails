h1. Создание откликов (часть вторая)

"&gt;&gt;&gt; Первая часть.":/layouts-and-rendering-in-rails/creating-responses-1

h4. Использование +redirect_to+

Другой способ управлять возвратом отклика на запрос HTTP - с помощью +redirect_to+. Как вы видели, +render+ говорит Rails, какую вьюху (или иной ресурс) использовать в создании ответа. Метод +redirect_to+ делает нечто полностью отличное: он говорит браузеру послать новый запрос по другому URL. Например, можно перенаправить из того места, где сейчас выполняется код, в индекс фотографий вашего приложения, с помощью этого вызова:

<ruby>
redirect_to photos_path
</ruby>

+redirect_to+ можно использовать с любыми аргументами, которые могут использоваться с +link_to+ или +url_for+. Дополнительно, есть специальное перенаправление, которое посылает пользователя обратно на страницу, с которой он пришел:

<ruby>
redirect_to :back
</ruby>

h5. Получение различного кода статуса перенаправления

Rails использует код статуса HTTP 302 (временное перенаправление) при вызыве +redirect_to+. Если хотите использовать иной код статуса (возможно 301, постоянное перенаправление), можете использовать опцию +:status+:

<ruby>
redirect_to photos_path, :status => 301
</ruby>

Подобно опции +:status+ для +render+, +:status+ для +redirect_to+ принимает и числовые, и символьные обозначения заголовка.

h5. Различие между +render+ и +redirect_to+

Иногда неопытные разработчики представляют себе +redirect_to+ как разновидность команды +goto+, перемещающую выполнение из одного места в другое в вашем коде Rails. Это _не_ правильно. Ваш код останавливается и ждет нового запроса от браузера. Просто получается так, что вы говорите браузеру, какой запрос он должен сделать следующим, возвращая код статуса HTTP 302.

Рассмотрим эти экшны, чтобы увидеть разницу:

<ruby>
def index
  @books = Book.all
end

def show
  @book = Book.find_by_id(params[:id])
  if @book.nil?
    render :action => "index"
  end
end
</ruby>

С кодом в такой форме, вероятно, будет проблема, если переменная +@book+ равна +nil+. Помните, render :action+ не запускает какой-либо код в указанном экшне, таким образом ничего не будет присвоено переменной +@books+, от которой предположительно зависит вьюха +index+. Способ исправить это - использовать перенаправление вместо рендера:

<ruby>
def index
  @books = Book.all
end

def show
  @book = Book.find_by_id(params[:id])
  if @book.nil?
    redirect_to :action => :index
  end
end
</ruby>

С таким кодом браузер сделает новый запрос для индексной страницы, код в методе +index+ запустится, и все будет хорошо.

Единственный недостаток этого кода в том, что он требует круговорот через браузер, браузер запрашивает экшн show с помощью +/books/1+, и контроллер обнаруживает, что книг нет, поэтому отсылает отклик-перенаправление 301 браузеру, сообщающий перейти на +/books/+, браузер выполняет и посылает новый запрос контроллеру, теперь запрашивая экшн +index+, затем контроллер получает все книги в базе данных и рендерит шаблон index, отсылает его обратно браузеру, который затем показывает его на экране.

Пока это небольшое приложение, такое состояние не может быть проблемой, но иногда стоит подумать, что скорость отклика существенна. Одним из способов управления этим двойным запросом (хотя это и хитрость) может быть код:

<ruby>
def index
  @books = Book.all
end

def show
  @book = Book.find_by_id(params[:id])
  if @book.nil?
    @books = Book.all
    render "index", :alert => 'Your book was not found!'
  end
end
</ruby>

Который, обнаружив, что нет книг, заполнит переменную экземпляра +@books+ всеми книгами в базе данных, и затем напрямую отрендерит шаблон +index.html.erb+, возвратив его браузеру с предупреждающим сообщением в flash, сообщающим пользователю, что произошло.

h4. Использование +head+ для создания отклика, содержащего только заголовок

Метод +head+ существует, чтобы позволить возвращать отклики браузеру, содержащие только заголовки. Он представляет более явную альтернативу вызова +render :nothing+. Метод +head+ принимает один параметр, который интерпретируется как хэш имен заголовков и значений. Например, можете возвратить только заголовок ошибки:

<ruby>
head :bad_request
</ruby>

Что создаст следующий заголовок:

<shell>
HTTP/1.1 400 Bad Request
Connection: close
Date: Sun, 24 Jan 2010 12:15:53 GMT
Transfer-Encoding: chunked
Content-Type: text/html; charset=utf-8
X-Runtime: 0.013483
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
</shell>

Или можете использовать другие заголовки HTTP для передачи дополнительной информации:

<ruby>
head :created, :location => photo_path(@photo)
</ruby>

Что создаст:

<shell>
HTTP/1.1 201 Created
Connection: close
Date: Sun, 24 Jan 2010 12:16:44 GMT
Transfer-Encoding: chunked
Location: /photos/1
Content-Type: text/html; charset=utf-8
X-Runtime: 0.083496
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
</shell>
